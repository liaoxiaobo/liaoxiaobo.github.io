<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>混沌工程系列：Chaos-Mesh工具使用实战</title>
    <url>/2021/10/15/chaos-tool/</url>
    <content><![CDATA[<h2 id="安装相关问题记录"><a href="#安装相关问题记录" class="headerlink" title="安装相关问题记录"></a>安装相关问题记录</h2><h3 id="1、没有list-ep的权限"><a href="#1、没有list-ep的权限" class="headerlink" title="1、没有list ep的权限"></a>1、没有list ep的权限</h3><img src="/2021/10/15/chaos-tool/image.png" class="" title="image">

<p>解决办法：手动部署一个rolebiding文件（为啥该文件没有自动部署？）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">chaos-mesh-chaos-controller-manager-control-plane</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">chaos-testing</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">chaos-mesh-chaos-controller-manager-control-plane</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">chaos-controller-manager</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">chaos-testing</span></span><br></pre></td></tr></table></figure>

<h3 id="2、chaos-pod没有创建出来-偶现"><a href="#2、chaos-pod没有创建出来-偶现" class="headerlink" title="2、chaos pod没有创建出来(偶现)"></a>2、chaos pod没有创建出来(偶现)</h3><p>pod安全策略导致，错误如下</p>
<img src="/2021/10/15/chaos-tool/1633950437536-81c7b128-3f83-4b2f-9b7b-90408bf6dda6.png" class="" title="1633950437536-81c7b128-3f83-4b2f-9b7b-90408bf6dda6">

<p>解决办法：手动部署一个psp文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">psp-chaos-testing</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">chaos-testing</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">psp-privileged</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Group</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:serviceaccounts:chaos-testing</span></span><br></pre></td></tr></table></figure>

<h3 id="3、ARM环境编译镜像遇到的问题记录"><a href="#3、ARM环境编译镜像遇到的问题记录" class="headerlink" title="3、ARM环境编译镜像遇到的问题记录"></a>3、ARM环境编译镜像遇到的问题记录</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">安装docker（20+版本以上，需要支持</span> <span class="string">--load</span> <span class="string">参数）</span></span><br><span class="line"><span class="string">安装golang</span></span><br><span class="line"><span class="string">git</span> <span class="string">clone</span> <span class="string">https://github.com/chaos-mesh/chaos-mesh.git</span></span><br><span class="line"><span class="string">cd</span> <span class="string">chaos-mesh</span> <span class="string">&amp;&amp;</span> <span class="string">UI=1</span> <span class="string">make</span> <span class="string">chaos-dashboard</span></span><br></pre></td></tr></table></figure>

<p>1、make过程中报–platform错误</p>
<img src="/2021/10/15/chaos-tool/1634564802940-fc178220-a332-48dc-8437-33bf702a7b52.png" class="" title="1634564802940-fc178220-a332-48dc-8437-33bf702a7b52.png">

<p><a href="https://thenew[stack.io/how-to-enable-docker-experimental-features-and-encrypt-your-login-credentials/](http://stack.io/how-to-enable-docker-experimental-features-and-encrypt-your-login-credentials/)">https://thenew[stack.io/how-to-enable-docker-experimental-features-and-encrypt-your-login-credentials/](http://stack.io/how-to-enable-docker-experimental-features-and-encrypt-your-login-credentials/)</a></p>
<p>2、make过程中遇到TLSHandshakeTimeout</p>
<img src="/2021/10/15/chaos-tool/1634637158658-a6ec02a6-1e6f-4914-9388-3c5808c9266f.png" class="" title="1634637158658-a6ec02a6-1e6f-4914-9388-3c5808c9266f.png">

<p>在arm机器上go get则正常，容器内go get mod包出现TLSHandshakeTimeout 解决办法：在Makefile文件中增加docker run参数，把容器网络改为主机网络，重新make编译即可解决。 具体问题原因链接见：</p>
<p><a href="https://github.com/goproxy/goproxy.cn/issues/26">https://github.com/goproxy/goproxy.cn/issues/26</a></p>
<img src="/2021/10/15/chaos-tool/1634637331537-effd5a34-89d2-44a2-9401-330d23ea8ee2.png" class="" title="1634637331537-effd5a34-89d2-44a2-9401-330d23ea8ee2.png">

<h2 id="模拟-Pod-故障"><a href="#模拟-Pod-故障" class="headerlink" title="模拟 Pod 故障"></a>模拟 Pod 故障</h2><h3 id="PodChaos-介绍"><a href="#PodChaos-介绍" class="headerlink" title="PodChaos 介绍"></a>PodChaos 介绍</h3><p>PodChaos 是 Chaos Mesh 中的一种故障类型，通过创建 PodChaos 类型的混沌实验，你可以模拟指定 Pod 或者容器发生故障的情景。目前，PodChaos 支持模拟以下故障类型：</p>
<ul>
<li>Pod Failure：向指定的 Pod 中注入故障，使得该 Pod 在一段时间内处于不可用的状态。</li>
<li>Pod Kill：杀死指定的 Pod 。为了保证 Pod 能够成功重启，需要配置 ReplicaSet 或者类似的机制。</li>
<li>Container Kill：杀死位于目标 Pod 中的指定容器。</li>
</ul>
<p><em>使用限制：Chaos Mesh 不支持向独立的 Pod 中注入故障，独立的 Pod 指未绑定到 ReplicaSet 或 Deployment 的 Pod。</em> </p>
<h3 id="pod-failure-示例"><a href="#pod-failure-示例" class="headerlink" title="pod-failure 示例"></a>pod-failure 示例</h3><blockquote>
<p>*PodFailure 是通过 Patch Pod 对象资源，用错误的镜像替换 Pod 中的镜像。Chaos 只修改了 <strong><code>containers</code></strong> 和 <strong><code>initContainers</code></strong> 的 <strong><code>image</code></strong> 字段，这也是因为 Pod 大部分字段是无法更改的。默认用于引发故障的容器镜像是 **<code>gcr.io/google-containers/pause:latest</code>**， 如果在国内环境使用，大概率会水土不服，可以将 <strong><code>gcr.io</code></strong> 替换为 **<code>registry.aliyuncs.com</code>*<em>。</em></p>
</blockquote>
<p>1、将实验配置写入到文件中 pod-failure.yaml，内容示例如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">chaos-mesh.org/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodChaos</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-failure-example</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">chaos-testing</span> <span class="comment"># 指定ns下创建PodChaos实例,缺省default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">action:</span> <span class="string">pod-failure</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="string">one</span></span><br><span class="line">  <span class="attr">duration:</span> <span class="string">&#x27;30s&#x27;</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">namespaces:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ems</span></span><br><span class="line">    <span class="attr">labelSelectors:</span></span><br><span class="line">      <span class="attr">&#x27;application&#x27;:</span> <span class="string">&#x27;ecp-dashboard&#x27;</span></span><br></pre></td></tr></table></figure>

<p>2、启动该实验，Chaos Mesh 将向指定的 Pod 中注入 pod-failure 故障，将使该 Pod 在 30 秒内处于不可用的状态。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="string">root@node-4</span> <span class="string">experiments</span>]<span class="comment"># kos apply -f pod-failure-example.yaml</span></span><br><span class="line"><span class="string">podchaos.chaos-mesh.org/pod-failure-example</span> <span class="string">created</span></span><br><span class="line">[<span class="string">root@node-4</span> <span class="string">experiments</span>]<span class="comment"># kos get PodChaos</span></span><br><span class="line"><span class="string">NAME</span>                  <span class="string">AGE</span></span><br><span class="line"><span class="string">pod-failure-example</span>   <span class="string">40s</span></span><br></pre></td></tr></table></figure>

<p>3、执行命令 kos describe PodChaos  pod-failure-example，可以查看到该实验的目标pod name，以及30s后实验结束并恢复故障</p>
<img src="/2021/10/15/chaos-tool/1633944471571-2af73cb6-c652-44e9-a4af-37a85170a52a.png" class="" title="1633944471571-2af73cb6-c652-44e9-a4af-37a85170a52a.png">

<p>4、查看pod，可知目标pod出现了故障，被重启过一次</p>
<img src="/2021/10/15/chaos-tool/1633944967210-66033f95-45ba-4ac7-a30b-0e28b7491fbc.png" class="" title="1633944967210-66033f95-45ba-4ac7-a30b-0e28b7491fbc.png">

<h3 id="pod-kill-示例"><a href="#pod-kill-示例" class="headerlink" title="pod-kill 示例"></a>pod-kill 示例</h3><blockquote>
<p><em>PodKill 的具体实现其实是通过调用 API Server 发送 Kill 命令。</em></p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">chaos-mesh.org/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodChaos</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-kill-example</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">chaos-testing</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">action:</span> <span class="string">pod-kill</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="string">all</span></span><br><span class="line">  <span class="comment">#gracePeriod: 10</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">namespaces:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ems</span></span><br><span class="line">    <span class="attr">labelSelectors:</span></span><br><span class="line">      <span class="attr">&#x27;application&#x27;:</span> <span class="string">&#x27;ecp-dashboard&#x27;</span></span><br></pre></td></tr></table></figure>

<p>依据此配置示例，Chaos Mesh 将向指定的 Pod 中注入 pod-kill 故障，将使该 Pod 被杀死一次。 </p>
<p>Tips：</p>
<p><em>1、实验被创建后，pod立刻就被全部kill；pod在被杀死一次后，实验立刻就结束了。</em></p>
<p>2、<code>GracePeriod</code> 参数适用于 K8s 强制终止 Pod。例如在需要快速删除 Pod 时，我们使用 <code>kubectl delete pod --grace-period=0 --force</code> 命令。</p>
<p>3、如果要达到持续kill的场景，需要结合schedule来运行实验 </p>
<h3 id="container-kill-示例"><a href="#container-kill-示例" class="headerlink" title="container-kill 示例"></a>container-kill 示例</h3><blockquote>
<p><em>ContainerKill 不同于 PodKill 和 PodFailure，后两个都是通过 K8s API Server 控制 Pod 生命周期，而 ContainerKill 是通过运行在集群 Node 上的 Chaos Daemon 程序操作完成。具体来说，ContainerKill 通过 Chaos Controller Manager 运行客户端向 Chaos Daemon 发起 grpc 调用。</em></p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">chaos-mesh.org/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodChaos</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">container-kill</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">chaos-testing</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">action:</span> <span class="string">container-kill</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">duration:</span> <span class="string">&#x27;60s&#x27;</span></span><br><span class="line">  <span class="attr">containerNames:</span> [<span class="string">&#x27;ecp-dashboard&#x27;</span>]</span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">namespaces:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ems</span></span><br><span class="line">    <span class="attr">labelSelectors:</span></span><br><span class="line">      <span class="attr">&#x27;application&#x27;:</span> <span class="string">&#x27;ecp-dashboard&#x27;</span></span><br></pre></td></tr></table></figure>

<p>依据此配置示例，Chaos Mesh 将向指定的 Container 中注入 container-kill 故障，将使该 Container 被杀死一次。</p>
<h3 id="字段说明"><a href="#字段说明" class="headerlink" title="字段说明"></a>字段说明</h3><table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>说明</th>
<th>默认值</th>
<th>是否必填</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>action</td>
<td>string</td>
<td>指定要注入的故障类型，仅支持 pod-failure、pod-kill、container-kill</td>
<td>无</td>
<td>是</td>
<td>pod-kill</td>
</tr>
<tr>
<td>mode</td>
<td>string</td>
<td>指定实验的运行方式，可选择的方式包括：one（表示随机选出一个符合条件的 Pod）、all（表示选出所有符合条件的 Pod）、fixed（表示选出指定数量且符合条件的 Pod）、fixed-percent（表示选出占符合条件的 Pod 中指定百分比的 Pod）、random-max-percent（表示选出占符合条件的 Pod 中不超过指定百分比的 Pod）</td>
<td>无</td>
<td>是</td>
<td>one</td>
</tr>
<tr>
<td>value</td>
<td>string</td>
<td>取决与 mode 的配置，为 mode 提供对应的参数。例如，当你将 mode 配置为 fixed-percent 时，value 用于指定 Pod 的百分比。</td>
<td>无</td>
<td>否</td>
<td>2</td>
</tr>
<tr>
<td>selector</td>
<td>struct</td>
<td>指定注入故障的目标 Pod，详情请参考<a href="https://chaos-mesh.org/zh/docs/define-chaos-experiment-scope/">定义实验范围</a></td>
<td>无</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>containerNames</td>
<td>[]string</td>
<td>当你将 action 配置为 container-kill 时，此配置为必填，用于指定注入故障的目标 container 名</td>
<td>无</td>
<td>否</td>
<td>[‘prometheus’]</td>
</tr>
<tr>
<td>gracePeriod</td>
<td>int64</td>
<td>当你将 action 配置为 pod-kill 时，需要填写此项，用于指定删除 Pod 之前的持续时间</td>
<td>0</td>
<td>否</td>
<td>0</td>
</tr>
<tr>
<td>duration</td>
<td>string</td>
<td>指定实验的持续时间</td>
<td>无</td>
<td>是</td>
<td>30s</td>
</tr>
</tbody></table>
<h2 id="模拟压力场景"><a href="#模拟压力场景" class="headerlink" title="模拟压力场景"></a>模拟压力场景</h2><h3 id="StressChaos-介绍"><a href="#StressChaos-介绍" class="headerlink" title="StressChaos 介绍"></a>StressChaos 介绍</h3><blockquote>
<p><em>StressChaos 类型的混沌也是由 Chaos Daemon 实施的，Controller Manager 计算好规则后就将任务下发到具体的 Daemon 上。拼装的参数如下，这些参数会组合成命令执行的参数，附加到 <strong><code>stress-ng</code></strong> 命令后执行</em></p>
</blockquote>
<p>Chaos Mesh 提供的 StressChaos 实验类型可用于模拟容器内压力的场景。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">chaos-mesh.org/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StressChaos</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">stress</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">chaos-testing</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">duration:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">namespaces:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ems</span></span><br><span class="line">    <span class="attr">labelSelectors:</span></span><br><span class="line">      <span class="attr">&#x27;application&#x27;:</span> <span class="string">&#x27;ecp-dashboard&#x27;</span></span><br><span class="line">  <span class="attr">stressors:</span></span><br><span class="line">    <span class="attr">memory:</span></span><br><span class="line">      <span class="attr">workers:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">size:</span> <span class="string">&#x27;1024MB&#x27;</span></span><br><span class="line">    <span class="attr">cpu:</span></span><br><span class="line">      <span class="attr">workers:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">load:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>该实验配置会在选中容器中创建worker进程，不断分配和在内存中进行读写，最多占用 1024MB 内存和2核cpu</p>
<h2 id="模拟文件-I-O-故障"><a href="#模拟文件-I-O-故障" class="headerlink" title="模拟文件 I&#x2F;O 故障"></a>模拟文件 I&#x2F;O 故障</h2><h3 id="IOChaos-介绍"><a href="#IOChaos-介绍" class="headerlink" title="IOChaos 介绍"></a>IOChaos 介绍</h3><p>目前，IOChaos 支持模拟以下故障类型：</p>
<ul>
<li>latency：为文件系统调用加入延迟</li>
<li>fault：使文件系统调用返回错误</li>
<li>attrOverride：修改文件属性</li>
<li>mistake：使文件读到或写入错误的值</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>创建 IOChaos 实验前，请确保目标 Pod 上没有运行 Chaos Mesh 的 Controller Manager。</li>
<li>IOChaos 可能会损坏你的数据，在生产环境中请<strong>谨慎</strong>使用</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">chaos-mesh.org/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">IOChaos</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">io-latency-example</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">chaos-testing</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">action:</span> <span class="string">latency</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="string">one</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">namespaces:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">openstack</span></span><br><span class="line">    <span class="attr">labelSelectors:</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">volumePath:</span> <span class="string">/host-log/containers</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;/host-log/containers/**/*&#x27;</span></span><br><span class="line">  <span class="attr">delay:</span> <span class="string">&#x27;1000ms&#x27;</span></span><br><span class="line">  <span class="attr">percent:</span> <span class="number">50</span></span><br><span class="line">  <span class="attr">duration:</span> <span class="string">&#x27;400s&#x27;</span></span><br></pre></td></tr></table></figure>

<p>依据此配置示例，Chaos Mesh 将向 &#x2F;host-log&#x2F;containers 目录注入延迟故障，使该目录下的所有文件系统操作（包括读，写，列出目录内容等）产生 1 秒延迟。 </p>
<p>注入故障时遇到该问题</p>
<img src="/2021/10/15/chaos-tool/1634089583922-c06ad231-32a6-4389-aee2-7b56410e763b.png" class="" title="1634089583922-c06ad231-32a6-4389-aee2-7b56410e763b.png">

<p>计划：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">chaos-mesh.org/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Schedule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ovn-pod-random-kill</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">chaos-testing</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">concurrencyPolicy:</span> <span class="string">Forbid</span></span><br><span class="line">  <span class="attr">historyLimit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">podChaos:</span></span><br><span class="line">    <span class="attr">action:</span> <span class="string">pod-kill</span></span><br><span class="line">    <span class="attr">duration:</span> <span class="string">48h</span></span><br><span class="line">    <span class="attr">gracePeriod:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">one</span></span><br><span class="line">    <span class="attr">selector:</span></span><br><span class="line">      <span class="attr">labelSelectors:</span></span><br><span class="line">        <span class="attr">application:</span> <span class="string">ovn</span></span><br><span class="line">      <span class="attr">namespaces:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">openstack</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&#x27;*/30 * * * *&#x27;</span></span><br><span class="line">  <span class="attr">startingDeadlineSeconds:</span> <span class="number">86400</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">PodChaos</span></span><br></pre></td></tr></table></figure>

<h2 id="Schedule实验场景"><a href="#Schedule实验场景" class="headerlink" title="Schedule实验场景"></a>Schedule实验场景</h2><h3 id="每隔30分钟，随机kill符合条件的pod"><a href="#每隔30分钟，随机kill符合条件的pod" class="headerlink" title="每隔30分钟，随机kill符合条件的pod"></a>每隔30分钟，随机kill符合条件的pod</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">chaos-mesh.org/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Schedule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ovn-pod-kill</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">chaos-testing</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">concurrencyPolicy:</span> <span class="string">Forbid</span></span><br><span class="line">  <span class="attr">historyLimit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">podChaos:</span></span><br><span class="line">    <span class="attr">action:</span> <span class="string">pod-kill</span></span><br><span class="line">    <span class="attr">gracePeriod:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">one</span></span><br><span class="line">    <span class="attr">selector:</span></span><br><span class="line">      <span class="attr">labelSelectors:</span></span><br><span class="line">        <span class="attr">application:</span> <span class="string">ovn</span></span><br><span class="line">      <span class="attr">namespaces:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">openstack</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&#x27;*/30 * * * *&#x27;</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">PodChaos</span></span><br></pre></td></tr></table></figure>

<h3 id="每隔10分钟，指定kill-container-proton-server"><a href="#每隔10分钟，指定kill-container-proton-server" class="headerlink" title="每隔10分钟，指定kill container proton-server"></a>每隔10分钟，指定kill container proton-server</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">chaos-mesh.org/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Schedule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ovn-container-kill</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">chaos-testing</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">concurrencyPolicy:</span> <span class="string">Forbid</span></span><br><span class="line">  <span class="attr">historyLimit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">podChaos:</span></span><br><span class="line">    <span class="attr">action:</span> <span class="string">container-kill</span></span><br><span class="line">    <span class="attr">duration:</span> <span class="string">1h</span></span><br><span class="line">    <span class="attr">containerNames:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">proton-server</span></span><br><span class="line">    <span class="attr">gracePeriod:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">one</span></span><br><span class="line">    <span class="attr">selector:</span></span><br><span class="line">      <span class="attr">labelSelectors:</span></span><br><span class="line">        <span class="attr">application:</span> <span class="string">proton</span></span><br><span class="line">      <span class="attr">namespaces:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">openstack</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&#x27;*/10 * * * *&#x27;</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">PodChaos</span></span><br></pre></td></tr></table></figure>

<h3 id="每隔10分钟，随机注入pod产生网络延迟，持续2min"><a href="#每隔10分钟，随机注入pod产生网络延迟，持续2min" class="headerlink" title="每隔10分钟，随机注入pod产生网络延迟，持续2min"></a>每隔10分钟，随机注入pod产生网络延迟，持续2min</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Schedule</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">chaos-mesh.org/v1alpha1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ovndb-sb-network-delay</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&#x27;*/10 * * * *&#x27;</span></span><br><span class="line">  <span class="attr">startingDeadlineSeconds:</span> <span class="number">3600</span></span><br><span class="line">  <span class="attr">concurrencyPolicy:</span> <span class="string">Forbid</span></span><br><span class="line">  <span class="attr">historyLimit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NetworkChaos</span></span><br><span class="line">  <span class="attr">networkChaos:</span></span><br><span class="line">    <span class="attr">selector:</span></span><br><span class="line">      <span class="attr">namespaces:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">openstack</span></span><br><span class="line">      <span class="attr">labelSelectors:</span></span><br><span class="line">        <span class="attr">component:</span> <span class="string">ovn-ovsdb-sb</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">one</span></span><br><span class="line">    <span class="attr">action:</span> <span class="string">delay</span></span><br><span class="line">    <span class="attr">duration:</span> <span class="string">120s</span></span><br><span class="line">    <span class="attr">delay:</span></span><br><span class="line">      <span class="attr">latency:</span> <span class="string">1s</span></span><br><span class="line">      <span class="attr">correlation:</span> <span class="string">&#x27;100&#x27;</span></span><br><span class="line">      <span class="attr">jitter:</span> <span class="string">&#x27;0ms&#x27;</span></span><br><span class="line">    <span class="comment">#direction: to</span></span><br></pre></td></tr></table></figure>

<h3 id="每隔10分钟，随机注入pod产生压力，持续2min"><a href="#每隔10分钟，随机注入pod产生压力，持续2min" class="headerlink" title="每隔10分钟，随机注入pod产生压力，持续2min"></a>每隔10分钟，随机注入pod产生压力，持续2min</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Schedule</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">chaos-mesh.org/v1alpha1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ovn-controller-cpu-load-80</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&#x27;*/60 * * * *&#x27;</span></span><br><span class="line">  <span class="attr">startingDeadlineSeconds:</span> <span class="number">60</span></span><br><span class="line">  <span class="attr">concurrencyPolicy:</span> <span class="string">Forbid</span></span><br><span class="line">  <span class="attr">historyLimit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">StressChaos</span></span><br><span class="line">  <span class="attr">stressChaos:</span></span><br><span class="line">    <span class="attr">selector:</span></span><br><span class="line">      <span class="attr">namespaces:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">openstack</span></span><br><span class="line">      <span class="attr">labelSelectors:</span></span><br><span class="line">        <span class="attr">component:</span> <span class="string">ovn-controller</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">one</span></span><br><span class="line">    <span class="attr">stressors:</span></span><br><span class="line">      <span class="attr">memory:</span></span><br><span class="line">        <span class="attr">workers:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">size:</span> <span class="string">&#x27;1024&#x27;</span></span><br><span class="line">      <span class="attr">cpu:</span></span><br><span class="line">        <span class="attr">workers:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">load:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">duration:</span> <span class="string">120s</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>混沌工程</category>
      </categories>
      <tags>
        <tag>Chaos Mesh</tag>
        <tag>Chaos Blade</tag>
      </tags>
  </entry>
  <entry>
    <title>混沌工程系列：基础知识与工具调研</title>
    <url>/2021/09/21/chaos/</url>
    <content><![CDATA[<h1 id="混沌工程"><a href="#混沌工程" class="headerlink" title="混沌工程"></a>混沌工程</h1><h2 id="混沌工程是什么"><a href="#混沌工程是什么" class="headerlink" title="混沌工程是什么"></a>混沌工程是什么</h2><p>混沌工程（Chaos Engineering）是在分布式系统上进行实验的学科, 目的是建立对系统抵御生产环境中失控条件的能力以及信心。</p>
<h2 id="为什么需要混沌工程"><a href="#为什么需要混沌工程" class="headerlink" title="为什么需要混沌工程"></a>为什么需要混沌工程</h2><ol>
<li><strong>分布式系统的复杂性挑战</strong></li>
</ol>
<ul>
<li><strong>服务依赖挑战</strong>：微服务架构下服务间调用链路复杂，单点故障可能引发级联失效</li>
<li><strong>环境动态性</strong>：云原生环境中的弹性伸缩、自动扩缩容&amp;回滚增加了不确定性</li>
<li><strong>传统测试局限</strong>：单元测试&#x2F;集成测试难以覆盖真实生产环境中的复杂故障场景</li>
</ul>
<ol start="2">
<li><strong>业务稳定性需求</strong></li>
</ol>
<ul>
<li><strong>金融级SLA要求</strong>：99.999%可用性目标需要验证极端场景下的系统表现</li>
<li><strong>故障恢复能力验证</strong>：验证熔断、降级、重试等容错机制的有效性</li>
</ul>
<p>总之，云原生的发展不断推进着微服务的进一步解耦，海量的数据与用户规模也带来了基础设施的大规模分布式演进。分布式系统天生有着各种相互依赖，可以出错的地方数不胜数，处理不好就会导致业务受损，或者是其他各种无法预期的异常行为。</p>
<h2 id="混沌工程原理"><a href="#混沌工程原理" class="headerlink" title="混沌工程原理"></a>混沌工程原理</h2><p>混沌工程的核心特征是<strong>对照观测实验</strong>。</p>
<p>为了具体地解决分布式系统在规模上的不确定性，可以把混沌工程看作是为了揭示系统弱点而进行的实验。这些实验通常包括如下步骤：</p>
<ol>
<li><strong>定义稳态：</strong>通过可量化的指标（响应时间、错误率等）定义系统正常运行的表现，为后续测试的有效性提供基准。</li>
<li><strong>构建假设</strong>：提出系统对故障的预期反应，确保在实验过程中有明确的衡量标准。</li>
<li><strong>故障注入：</strong>在实验组中主动注入特定的故障如 （Chaos Mesh、Chaos Monkey），以模拟生产环境中可能遇到的真实问题。如节点故障、硬盘故障、网络断开等。</li>
<li><strong>监控和观察：</strong>监控系统指标变化及恢复时间，对比实验组&#x2F;对照组之前的数据差异，评估是否符合实验假设。</li>
<li><strong>系统改进</strong>：根据实验结果，优化系统的故障处理机制，提升其可靠性。</li>
</ol>
<p>破坏稳态的难度越大，我们对系统行为的信心就越强。如果发现了一个弱点，那么我们就有了一个改进目标,避免在系统规模化之后被放大。</p>
<img src="/2021/09/21/chaos/image-20250424161057598.png"  alt="img" style="zoom:50%;" />



<h2 id="混沌工程的重要原则"><a href="#混沌工程的重要原则" class="headerlink" title="混沌工程的重要原则"></a>混沌工程的重要原则</h2><p>以下原则描述了混沌工程的理想应用，应用于上述的实验过程。遵循这些原则的程度与我们对大规模分布式系统的信心密切相关。</p>
<h3 id="在生产环境中运行实验"><a href="#在生产环境中运行实验" class="headerlink" title="在生产环境中运行实验"></a>在生产环境中运行实验</h3><p>系统的行为因环境和流量模式而异。由于利用率的行为随时可能发生变化，因此对真实流量进行采样是可靠捕获请求路径的唯一方法。为了保证系统运行方式的真实性以及与当前部署系统的相关性，Chaos 强烈倾向于直接在生产流量上进行试验。</p>
<h3 id="自动化实验以连续运行"><a href="#自动化实验以连续运行" class="headerlink" title="自动化实验以连续运行"></a>自动化实验以连续运行</h3><p>手动运行实验是劳动密集型的，最终是不可持续的。自动化实验并连续运行它们。混沌工程将自动化构建到系统中，以驱动编排和分析。</p>
<h3 id="最小化爆照半径"><a href="#最小化爆照半径" class="headerlink" title="最小化爆照半径"></a><strong>最小化爆照半径</strong></h3><p>混沌工程具备导致生产环境崩溃的风险，所谓“最小化爆炸半径”就是尽量让薄弱环节暴露出来，又不会造成更大规模的故障。</p>
<p>可以采用分阶段实验策略：</p>
<ol>
<li>单服务实例故障</li>
<li>单集群故障</li>
<li>跨区域故障</li>
</ol>
<p>另外，《混沌工程》中详细介绍了几个步骤：</p>
<ul>
<li>采用递进的方式进行实验；</li>
<li>只向一小部分终端（用户）注入故障；</li>
<li>开始进行小规模的扩散实验（需要定义好指标来过滤真正通过测试的用户）；</li>
<li>小规模集中实验，不断扩大实验范围（有定义的路由实验，无定义路由的大规模实验……）；</li>
<li>在实验造成过多危害时，自动终止实验；</li>
<li>避免在高风险时段进行实验（所有人都要在工作状态内）</li>
<li>运行实验本身不能对系统造成过大影响，造成结果偏移。每次只检验一个可控故障；</li>
</ul>
<img src="/2021/09/21/chaos/image.png"  alt="img" style="zoom:50%;" />



<h1 id="混沌测试工具调研"><a href="#混沌测试工具调研" class="headerlink" title="混沌测试工具调研"></a>混沌测试工具调研</h1><img src="/2021/09/21/chaos/image-20250424161057566.png" class="" title="img">

<h2 id="Chaos-Mesh"><a href="#Chaos-Mesh" class="headerlink" title="Chaos Mesh"></a>Chaos Mesh</h2><p>2019 年 12 月 31 日，PingCap在 GitHub 上正式开源了 Chaos Mesh。作为一个云原生的混沌测试平台，Chaos Mesh 提供在 Kubernetes 平台上进行混沌测试的能力。</p>
<p>Chaos Mesh 通过运行在 K8s 集群中的 “特权” 容器，依据 CRD 资源中的测试场景，在集群中制造混沌（模拟故障）。</p>
<h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p>Chaos Mesh 的架构如下：</p>
<img src="/2021/09/21/chaos/1625389520612-41b84f9f-ec0c-48db-b2e3-511b5f432ee1.png" class="" title="img">

<ul>
<li><strong>Chaos Dashboard</strong>: a Web UI for managing, designing, monitoring Chaos Experiments.</li>
<li><strong>Controller-manager</strong>: used to schedule and manage the lifecycle of CRD objects</li>
<li><strong>Chaos-daemon</strong>: runs as daemonset with privileged system permissions over network, Cgroup, etc. for a specific node</li>
</ul>
<p><strong>CRD 设计</strong></p>
<p>Chaos Mesh 中使用 <a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/">CRD</a> 来定义 chaos 对象，在 Kubernetes 生态中 CRD 是用来实现自定义资源的成熟方案，又有非常成熟的实现案例和工具集，这样就可以避免重复造轮子。并且可以更好的融合到 Kubernetes 生态中。</p>
<p>Chaos Mesh 中 CRD 的定义可以自由发挥，根据不同的错误注入类型，定义单独的 CRD 对象。如果新添加的错误注入符合已有的 CRD 对象定义，就可以拓展这个 CRD 对象；如果是一个完全不同的错误注入类型，也可以自己重新增加一个 CRD 对象，这样的设计可以将不同的错误注入类型的定义以及逻辑实现从最顶层就抽离开，让代码结构看起来更加清晰，并且降低了耦合度，降低出错的几率。另一方面 <a href="https://github.com/kubernetes-sigs/controller-runtime">controller-runtime</a> 提供了很好的 controller 实现的封装，不用去对每一个 CRD 对象去自己实现一套 controller 的逻辑，避免了大量的重复劳动。</p>
<p>目前在 Chaos Mesh 中设计了三个 CRD 对象，分别是 PodChaos、NetworkChaos 以及 IOChaos，从命名上就可以很容易的区分这几个 CRD 对象分别对应的错误注入类型。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><img src="/2021/09/21/chaos/1625390750219-a9e4660b-b51c-40cd-839b-7808e164c0db.png"  alt="img" style="zoom:33%;" />

<p>上图是 Chaos Mesh 的基本工作流原理图：</p>
<ul>
<li>目前 controller-manager 可以分为两部分，一部分 controllers 用于调度和管理 CRD 对象实例，另一部分为 admission-webhooks 动态的给 Pod 注入 sidecar 容器。</li>
<li>Chaos-daemon 以 daemonset 的方式运行，并具有 Privileged 权限，Chaos-daemon 可以操作具体 Node 节点上网络设备以及 Cgroup 等。</li>
<li>Sidecar contianer 是一类特殊的容器，由 admission-webhooks 动态的注入到目标 Pod 中</li>
</ul>
<p>整体工作流如下：</p>
<ol>
<li>用户通过 YAML 文件或是 Kubernetes 客户端往 Kubernetes API Server 创建或更新 Chaos 对象。</li>
<li>Chaos-mesh 通过 watch API Server 中的 Chaos 对象创建更新或删除事件，维护具体 Chaos 实验的运行以及生命周期，在这个过程中 controller-manager、chaos-daemon 以及 sidecar 容器协同工作，共同提供错误注入的能力。</li>
<li>Admission-webhooks 是用来接收准入请求的 HTTP 回调服务，当收到 Pod 创建请求，会动态修改待创建的 Pod 对象，例如注入 sidecar 容器到 Pod 中。第 3 步也可以发生在第 2 步之前，在应用创建的时候运行。</li>
</ol>
<h3 id="功能支持"><a href="#功能支持" class="headerlink" title="功能支持"></a>功能支持</h3><h4 id="故障注入"><a href="#故障注入" class="headerlink" title="故障注入"></a>故障注入</h4><p>故障注入是混沌实验的核心。Chaos Mesh 充分考虑分布式系统可能出现的故障，提供全面、细粒度的故障类型，分为基础资源类型故障、平台类型故障和应用层故障三大类。</p>
<ul>
<li>基础资源类型故障：<ul>
<li><a href="https://chaos-mesh.org/zh/docs/simulate-pod-chaos-on-kubernetes/">PodChaos</a>：模拟 Pod 故障，例如 Pod 节点重启、Pod 持续不可用，以及特定 Pod 中的某些容器故障。</li>
<li><a href="https://chaos-mesh.org/zh/docs/simulate-network-chaos-on-kubernetes/">NetworkChaos</a>：模拟网络故障，例如网络延迟、网络丢包、包乱序、各类网络分区。</li>
<li><a href="https://chaos-mesh.org/zh/docs/simulate-dns-chaos-on-kubernetes/">DNSChaos</a>：模拟 DNS 故障，例如 DNS 域名解析失败、返回错误 IP 地址。</li>
<li><a href="https://chaos-mesh.org/zh/docs/simulate-http-chaos-on-kubernetes/">HTTPChaos</a>：模拟 HTTP 通信故障，例如 HTTP 通信延迟。</li>
<li><a href="https://chaos-mesh.org/zh/docs/simulate-heavy-stress-on-kubernetes/">StressChaos</a>：模拟 CPU 抢占或内存抢占场景。</li>
<li><a href="https://chaos-mesh.org/zh/docs/simulate-io-chaos-on-kubernetes/">IOChaos</a>：模拟具体某个应用的文件 I&#x2F;O 故障，例如 I&#x2F;O 延迟、读写失败。</li>
<li><a href="https://chaos-mesh.org/zh/docs/simulate-time-chaos-on-kubernetes/">TimeChaos</a>：模拟时间跳动异常。</li>
<li><a href="https://chaos-mesh.org/zh/docs/simulate-kernel-chaos-on-kubernetes/">KernelChaos</a>：模拟内核故障，例如应用内存分配异常。</li>
</ul>
</li>
<li>平台类型故障：<ul>
<li><a href="https://chaos-mesh.org/zh/docs/simulate-aws-chaos/">AWSChaos</a>：模拟 AWS 平台故障，例如 AWS 节点重启。</li>
<li><a href="https://chaos-mesh.org/zh/docs/simulate-gcp-chaos/">GCPChaos</a>：模拟 GCP 平台故障，例如 GCP 节点重启。</li>
</ul>
</li>
<li>应用层故障：<ul>
<li><a href="https://chaos-mesh.org/zh/docs/simulate-jvm-application-chaos/">JVMChaos</a>：模拟 JVM 应用故障，例如函数调用延迟。</li>
</ul>
</li>
</ul>
<h4 id="混沌实验场景"><a href="#混沌实验场景" class="headerlink" title="混沌实验场景"></a>混沌实验场景</h4><p>用户运行混沌场景，可以通过一系列的混沌实验，不断地扩大爆炸半径（包括攻击范围）和增加故障类型。运行混沌实验后，用户可以方便地检查当前的应用状态，判断是否需要进行后续混沌实验。同时用户可以不断地迭代混沌实验场景，积累混沌实验场景，以及方便地将已有的混沌实验场景复用到其他应用混沌实验中，大大降低了混沌实验的成本。</p>
<p>目前混沌实验场景提供的功能有：</p>
<ul>
<li>编排串行混沌实验</li>
<li>编排并行混沌实验</li>
<li>支持状态检查步骤</li>
<li>支持中途暂停混沌实验</li>
<li>支持使用 YAML 文件定义和管理混沌实验场景</li>
<li>支持通过 Web UI 定义和管理混沌实验场景</li>
</ul>
<p>具体的实验场景配置，参考具体<a href="https://chaos-mesh.org/zh/docs/create-chaos-mesh-workflow/">创建 Chaos Mesh Workflow</a>。</p>
<h4 id="可视化界面操作"><a href="#可视化界面操作" class="headerlink" title="可视化界面操作"></a>可视化界面操作</h4><p>Chaos Mesh 为用户提供了单独的 Chaos Dashboard 组件，即可视化支持。Chaos Dashboard 极大地简化了混沌实验，用户可以直接通过可视化界面来管理和监控混沌实验，仅需点一点鼠标就能够定义混沌实验的范围、指定混沌注入的类型、定义调度规则，以及在界面上获取到混沌实验的结果等。</p>
<img src="/2021/09/21/chaos/dashboard-overview-445b086ab6dbbdf6525405e17c12782b.png" class="" title="img">

<h4 id="安全保障"><a href="#安全保障" class="headerlink" title="安全保障"></a>安全保障</h4><p>Chaos Mesh 通过 Kubernetes 原生的 <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">RBAC</a>（基于角色的权限控制）功能对权限进行管理。</p>
<p>用户可以根据实际的权限需求自由地创建多种 Role，然后绑定到用户名 Service Account 上，最后生成 Service Account 对应的 Token。用户使用该 Token 登陆 Dashboard，只能在该 Service Account 允许的权限范围内进行 Chaos 实验。</p>
<p>此外 Chaos Mesh 还支持通过设置 Namespace Annotation 的方式开启特定 Namespace 下混沌实验的权限，进一步保障混沌实验的可控性。</p>
<h3 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h3><h4 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">wget</span> <span class="string">-O</span> <span class="string">/tmp/install.sh</span> <span class="string">https://mirrors.chaos-mesh.org/latest/install.sh</span></span><br><span class="line"><span class="string">sh</span> <span class="string">/tmp/install.sh</span> <span class="string">-r</span> <span class="string">containerd</span></span><br></pre></td></tr></table></figure>

<h4 id="helm安装"><a href="#helm安装" class="headerlink" title="helm安装"></a>helm安装</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">git</span> <span class="string">clone</span> <span class="string">https://github.com/pingcap/chaos-mesh.git</span></span><br><span class="line"><span class="string">cd</span> <span class="string">chaos-mesh</span></span><br><span class="line"><span class="string">//</span> <span class="string">创建</span> <span class="string">CRD</span> <span class="string">资源</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">manifests/</span></span><br><span class="line"><span class="string">//</span> <span class="string">安装</span> <span class="string">Chaos-mesh</span></span><br><span class="line"><span class="string">helm</span> <span class="string">install</span> <span class="string">helm/chaos-mesh</span> <span class="string">--name=chaos-mesh</span> <span class="string">--namespace=chaos-testing</span></span><br><span class="line"><span class="string">//</span> <span class="string">检查</span> <span class="string">Chaos-mesh</span> <span class="string">状态</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">get</span> <span class="string">pods</span> <span class="string">--namespace</span> <span class="string">chaos-testing</span> <span class="string">-l</span> <span class="string">app.kubernetes.io/instance=chaos-mesh</span></span><br></pre></td></tr></table></figure>

<p><strong>⚠️ Tips：docker hub上只有Chaos-Mesh每个Release版本的X86镜像，但是目前没有ARM镜像！</strong></p>
<p>如果安装环境是ARM，则需要在安装时需要指定仓库地址为 <code>ghcr.io/chaos-mesh/chaos-mesh/</code> ，或者安装后手动修改镜像地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">set</span> image deploy chaos-controller-manager chaos-mesh=ghcr.io/chaos-mesh/chaos-mesh/chaos-mesh:latest-arm64 -nchaos-testing</span><br><span class="line">kubectl <span class="built_in">set</span> image deploy chaos-dashboard chaos-dashboard=ghcr.io/chaos-mesh/chaos-mesh/chaos-dashboard:latest-arm64 -nchaos-testing</span><br><span class="line">kubectl <span class="built_in">set</span> image ds chaos-daemon chaos-daemon=ghcr.io/chaos-mesh/chaos-mesh/chaos-daemon:latest-arm64 -nchaos-testing</span><br></pre></td></tr></table></figure>

<h2 id="Chaos-Blade"><a href="#Chaos-Blade" class="headerlink" title="Chaos Blade"></a>Chaos Blade</h2><p>Chaosblade 是内部 MonkeyKing 对外开源的项目，其建立在阿里巴巴近十年故障测试和演练实践基础上，结合了集团各业务的最佳创意和实践。</p>
<h3 id="如何部署"><a href="#如何部署" class="headerlink" title="如何部署"></a>如何部署</h3><h4 id="容器内快速体验"><a href="#容器内快速体验" class="headerlink" title="容器内快速体验"></a><strong>容器内快速体验</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull chaosbladeio/chaosblade-demo</span><br><span class="line"></span><br><span class="line">docker run -it --privileged chaosbladeio/chaosblade-demo</span><br></pre></td></tr></table></figure>

<h4 id="二进制包安装"><a href="#二进制包安装" class="headerlink" title="二进制包安装"></a><strong>二进制包安装</strong></h4><p>获取 ChaosBlade 最新的 release 包，目前支持的平台是 linux&#x2F;amd64 和 darwin&#x2F;64，下载对应平台的包。</p>
<p><a href="https://github.com/chaosblade-io/chaosblade/releases">https://github.com/chaosblade-io/chaosblade/releases</a></p>
<p>下载完成后解压即可，解压之后的文件中有一个blade的可执行文件，这就是Chaosblade提供的客户端工具</p>
<h3 id="架构设计-1"><a href="#架构设计-1" class="headerlink" title="架构设计"></a>架构设计</h3><img src="/2021/09/21/chaos/1625451323095-d287b185-4d49-4100-83ed-83926dd71372.png" class="" title="img">

<h3 id="功能支持-1"><a href="#功能支持-1" class="headerlink" title="功能支持"></a>功能支持</h3><p>ChaosBlade 不仅使用简单，而且支持丰富的实验场景，场景包括：</p>
<ul>
<li>基础资源：比如 CPU、内存、网络、磁盘、进程等实验场景；</li>
<li>Java 应用：比如数据库、缓存、消息、JVM 本身、微服务等，还可以指定任意类方法注入各种复杂的实验场景；</li>
<li>C++ 应用：比如指定任意方法或某行代码注入延迟、变量和返回值篡改等实验场景；</li>
<li>Docker 容器：比如杀容器、容器内 CPU、内存、网络、磁盘、进程等实验场景；</li>
<li>云原生平台：比如 Kubernetes 平台节点上 CPU、内存、网络、磁盘、进程实验场景，Pod 网络和 Pod 本身实验场景如杀 Pod，容器的实验场景如上述的 Docker 容器实验场景</li>
</ul>
<h3 id="混沌实验模型"><a href="#混沌实验模型" class="headerlink" title="混沌实验模型"></a>混沌实验模型</h3><img src="/2021/09/21/chaos/1625417454000-d58d5840-0c6b-4bfa-b97e-8443863b0527.png"  alt="img" style="zoom:50%;" />

<p>以上所有的实验场景都遵循混沌实验模型，此模型共分为四层，包含：</p>
<ul>
<li>Target：实验靶点。指实验发生的组件，如容器、应用框架（Dubbo、Redis）等；</li>
<li>Scope：实验实施的范围。指具体触发实验的机器或者集群等；</li>
<li>Matcher：实验规则匹配器。根据所配置的 Target，定义相关的实验匹配规则，可以配置多个。由于每个 Target 可能有各自特殊的匹配条件，比如 RPC 领域的 Dubbo，可以根据服务提供者提供的服务和服务消费者调用的服务进行匹配，缓存领域的 Redis，可以根据 set、get 操作进行匹配；</li>
<li>Action：指实验模拟的具体场景，Target 不同，实施的场景也不一样，比如磁盘，可以演练磁盘满，磁盘 IO 读写高等。如果是应用，可以抽象出延迟、异常、返回指定值（错误码、大对象等）、参数篡改、重复调用等实验场景。</li>
</ul>
<h3 id="面向云原生"><a href="#面向云原生" class="headerlink" title="面向云原生"></a>面向云原生</h3><img src="/2021/09/21/chaos/1625417573541-6c050770-c514-41f9-9b9c-65e9922bac54.png"  alt="img" style="zoom:50%;" />

<p>将混沌实验场景按照上述的实验模型，定义为 Kubernetes 中的资源，并通过自定义控制器来管理，可以通过 Yaml 配置或者直接执行 blade 命令执行。</p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>使用方式有两种：</p>
<ul>
<li>一种是通过配置 yaml 方式，使用 kubectl 执行；</li>
<li>另一种是直接使用 chaosblade 包中的 blade 命令执行。</li>
</ul>
<p><strong>yaml 配置方式</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> [<span class="string">chaosblade.io/v1alpha1</span>]<span class="string">(http://chaosblade.io/v1alpha1)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ChaosBlade</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cpu-load</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">experiments:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">scope:</span> <span class="string">node</span></span><br><span class="line">    <span class="attr">target:</span> <span class="string">cpu</span></span><br><span class="line">    <span class="attr">action:</span> <span class="string">fullload</span></span><br><span class="line">    <span class="attr">desc:</span> <span class="string">&quot;increase node cpu load by names&quot;</span></span><br><span class="line">    <span class="attr">matchers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">names</span></span><br><span class="line">      <span class="attr">value:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;cn-hangzhou.192.168.0.205&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cpu-percent</span></span><br><span class="line">      <span class="attr">value:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>Blade相关命令</strong></p>
<ul>
<li><a href="">blade create</a> - 创建一个混沌实验</li>
<li>blade_destroy.md - 销毁一个混沌实验</li>
<li>blade_prepare.md - 准备混沌实验环境，部分实验执行前必须执行</li>
<li>blade_revoke.md - 撤销混沌实验环境，与 prepare 操作对应</li>
<li><a href="">blade status</a> - 查询混沌实验和混沌实验环境状态</li>
<li>blade_query.md - 查询部分实验所需的系统参数</li>
<li><a href="">blade version</a> - 打印 blade 工具版本信息</li>
<li><a href="">blade server</a> - server 模式</li>
</ul>
<img src="/2021/09/21/chaos/1625420367921-aa082d4a-1471-4613-a34d-07accaa1b4e3.png"  alt="img" style="zoom:50%;" />

<h2 id="工具调研总结"><a href="#工具调研总结" class="headerlink" title="工具调研总结"></a>工具调研总结</h2><p>基于对以上混沌工程的工具相关资料整理和学习，对三款工具进行对比总结如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><strong>Chaos Monkey</strong></td>
<td><strong>Chaos Mesh（1.2.2）</strong></td>
<td><strong>Chaos Blade（1.2.0）</strong></td>
</tr>
<tr>
<td>安装是否有特定依赖</td>
<td>Spinnaker</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>部署方式</td>
<td>Spinnaker上配置启用</td>
<td>helm部署、脚本部署</td>
<td>二进制包安装、容器直接运行</td>
</tr>
<tr>
<td>功能和特点</td>
<td>功能和实验场景单一，仅支持终止实例   不能支持云原生的实验场景</td>
<td>场景丰富度高，支持云原生   应用无侵入，类似于istio的sidecar设计</td>
<td>场景丰富度极高，支持云原生  应用无侵入，扩展性强</td>
</tr>
<tr>
<td>易用性</td>
<td>使用上手较困难</td>
<td>除了yaml文件编排，提供了dashboard编排界面；   单独开发了grafana插件，易于观测实验前后结果</td>
<td>简洁易用   通过 CLI 方式执行，具有友好的命令提示功能</td>
</tr>
<tr>
<td>社区活跃度</td>
<td>release周期长，最近release版本是在2016年   国内成熟的实践案例和相关资料较少</td>
<td>活跃度高</td>
<td>活跃度高，且国内已有较多成熟的实践案例</td>
</tr>
</tbody></table>
<img src="/2021/09/21/chaos/1634715689377-042ccfdf-9d12-4a27-9cb7-bdce627e802e.png" class="" title="img">

<hr>
<p><strong>参考资料：</strong></p>
<p><a href="https://www.infoq.cn/article/xbbm7mft8lecbzqh2bnw">https://www.infoq.cn/article/xbbm7mft8lecbzqh2bnw</a></p>
<p><a href="https://github.com/chaosops/awesome-chaos-engineering">https://github.com/chaosops/awesome-chaos-engineering</a></p>
<p><a href="https://www.infoq.cn/article/gsqtykoa3uvrtqi1kkmo">https://www.infoq.cn/article/gsqtykoa3uvrtqi1kkmo</a></p>
<p><a href="https://github.com/chaosblade-io/chaosblade/blob/master/README_CN.md">https://github.com/chaosblade-io/chaosblade/blob/master/README_CN.md</a></p>
<p><a href="https://chaos-mesh.org/docs/">https://chaos-mesh.org/docs/</a></p>
<p><a href="https://chaos-mesh.org/blog/Securing-Online-Gaming-Combine-Chaos-Engineering-with-DevOps-Practices/">https://chaos-mesh.org/blog/Securing-Online-Gaming-Combine-Chaos-Engineering-with-DevOps-Practices/</a></p>
]]></content>
      <categories>
        <category>混沌工程</category>
      </categories>
      <tags>
        <tag>Chaos Mesh</tag>
        <tag>Chaos Blade</tag>
      </tags>
  </entry>
  <entry>
    <title>常用工具-Git命令使用</title>
    <url>/2019/11/15/git_tool_note/</url>
    <content><![CDATA[<h3 id="代码拉取到本地"><a href="#代码拉取到本地" class="headerlink" title="代码拉取到本地"></a>代码拉取到本地</h3><h4 id="与主分支保持同步"><a href="#与主分支保持同步" class="headerlink" title="与主分支保持同步"></a>与主分支保持同步</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git pull origin main</span><br><span class="line">git checkout feature/my-new-feature</span><br><span class="line">git merge main</span><br></pre></td></tr></table></figure>
<h4 id="代码拉取冲突处理"><a href="#代码拉取冲突处理" class="headerlink" title="代码拉取冲突处理"></a>代码拉取冲突处理</h4><p><strong>1、保留并继续合并代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localhost:bookstore liaoxb$ git pull</span><br><span class="line">Updating d369e85..67e8e8a</span><br><span class="line">error: Your local changes to the following files would be overwritten by merge:</span><br><span class="line">	test.txt</span><br><span class="line">Please commit your changes or stash them before you merge.</span><br><span class="line">Aborting</span><br><span class="line">localhost:bookstore liaoxb$</span><br><span class="line">localhost:bookstore liaoxb$ echo &#x27;local change test&#x27; &gt; test.txt</span><br><span class="line">localhost:bookstore liaoxb$ git pull</span><br><span class="line">Updating d369e85..67e8e8a</span><br><span class="line">error: Your local changes to the following files would be overwritten by merge:</span><br><span class="line">	test.txt</span><br><span class="line">Please commit your changes or stash them before you merge.</span><br><span class="line">Aborting</span><br></pre></td></tr></table></figure>

<p>git stash 暂存本地的代码修改<br>git pull 拉取远端最新代码<br>git stash pop 合并暂存的本地代码，解决已冲突的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localhost:bookstore liaoxb$ git stash</span><br><span class="line">Saved working directory and index state WIP on master: d369e85 update</span><br><span class="line">localhost:bookstore liaoxb$ git pull</span><br><span class="line">Updating d369e85..67e8e8a</span><br><span class="line">Fast-forward</span><br><span class="line"> test.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line">localhost:bookstore liaoxb$ git stash pop</span><br><span class="line">Auto-merging test.txt</span><br><span class="line">CONFLICT (content): Merge conflict in test.txt</span><br></pre></td></tr></table></figure>

<p><strong>2、远端覆盖本地代码</strong></p>
<p>git reset –hard 回滚到上个版本<br>git pull</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localhost:bookstore liaoxb$ git reset --hard</span><br><span class="line">HEAD is now at d369e85 update</span><br><span class="line">localhost:bookstore liaoxb$ git pull</span><br><span class="line">Updating d369e85..67e8e8a</span><br><span class="line">Fast-forward</span><br><span class="line"> test.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<h3 id="创建分支并推送到远端"><a href="#创建分支并推送到远端" class="headerlink" title="创建分支并推送到远端"></a>创建分支并推送到远端</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建新分支,同时切换到bugfix1</span></span><br><span class="line">localhost:bookstore liaoxb$ git pull</span><br><span class="line">Already up to <span class="built_in">date</span>.</span><br><span class="line">localhost:bookstore liaoxb$ git checkout -b bugfix1</span><br><span class="line">Switched to a new branch <span class="string">&#x27;bugfix1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改并提交代码</span></span><br><span class="line">localhost:bookstore liaoxb$ <span class="built_in">echo</span> <span class="string">&#x27;bugfix test&#x27;</span> &gt; test.txt</span><br><span class="line">localhost:bookstore liaoxb$ git add .</span><br><span class="line">localhost:bookstore liaoxb$ git commit -m <span class="string">&quot;bugfix test&quot;</span></span><br><span class="line">[bugfix1 2eafe98] bugfix <span class="built_in">test</span></span><br><span class="line"> 1 file changed, 1 insertion(+), 3 deletions(-)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 新分支push到远端</span></span><br><span class="line">localhost:bookstore liaoxb$ git push --set-upstream origin bugfix1</span><br><span class="line">Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 259 bytes | 259.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 1), reused 0 (delta 0)</span><br><span class="line">remote: Powered by GITEE.COM [GNK-3.0]</span><br><span class="line">remote: Create a pull request <span class="keyword">for</span> <span class="string">&#x27;bugfix1&#x27;</span> on Gitee by visiting:</span><br><span class="line">remote:     https://gitee.com/wisecloud/bookstore/pull/new/wisecloud:bugfix1...wisecloud:master</span><br><span class="line">To https://gitee.com/wisecloud/bookstore.git</span><br><span class="line"> * [new branch]      bugfix1 -&gt; bugfix1</span><br><span class="line">Branch <span class="string">&#x27;bugfix1&#x27;</span> <span class="built_in">set</span> up to track remote branch <span class="string">&#x27;bugfix1&#x27;</span> from <span class="string">&#x27;origin&#x27;</span>.</span><br></pre></td></tr></table></figure>

<h3 id="代码合并到主分支"><a href="#代码合并到主分支" class="headerlink" title="代码合并到主分支"></a>代码合并到主分支</h3><h4 id="方法一：git-merge"><a href="#方法一：git-merge" class="headerlink" title="方法一：git merge"></a>方法一：git merge</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切至合并分支</span></span><br><span class="line">localhost:bookstore liaoxb$ git branch</span><br><span class="line">* bugfix1</span><br><span class="line">  master</span><br><span class="line">localhost:bookstore liaoxb$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">Your branch is up to <span class="built_in">date</span> with <span class="string">&#x27;origin/master&#x27;</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行合并操作</span></span><br><span class="line">localhost:bookstore liaoxb$ git merge bugfix1</span><br><span class="line">Updating d369e85..2eafe98</span><br><span class="line">Fast-forward</span><br><span class="line"> test.txt | 4 +---</span><br><span class="line"> 1 file changed, 1 insertion(+), 3 deletions(-)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># git push到远端</span></span><br><span class="line">localhost:bookstore liaoxb$ git push</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">remote: Powered by GITEE.COM [GNK-3.0]</span><br><span class="line">To https://gitee.com/wisecloud/bookstore.git</span><br><span class="line">   d369e85..2eafe98  master -&gt; master</span><br></pre></td></tr></table></figure>

<h4 id="方法二：git-cherry-pick"><a href="#方法二：git-cherry-pick" class="headerlink" title="方法二：git cherry-pick"></a>方法二：git cherry-pick</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到master分支</span></span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cherry pick 操作</span></span><br><span class="line">git cherry-pick &lt;commit_1&gt; &lt;commit_2&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行合并操作期间，若遇到代码冲突，需要先解决后，才能继续合并提交</p>
</blockquote>
<h4 id="代码合并冲突处理"><a href="#代码合并冲突处理" class="headerlink" title="代码合并冲突处理"></a>代码合并冲突处理</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解决完冲突后，将修改的文件重新加入暂存区</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续剩余的提交</span></span><br><span class="line">git cherry-pick --<span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 遇到冲突，放弃合并，回到操作前的样子</span></span><br><span class="line">git cherry-pick --abort</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遇到冲突，放弃合并，不回到操作前的样子</span></span><br><span class="line">git cherry-pick --quit</span><br></pre></td></tr></table></figure>

<h3 id="本地和远端删除已废弃分支"><a href="#本地和远端删除已废弃分支" class="headerlink" title="本地和远端删除已废弃分支"></a>本地和远端删除已废弃分支</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除远端分支</span></span><br><span class="line">localhost:bookstore liaoxb$ git branch -r</span><br><span class="line">  origin/HEAD -&gt; origin/master</span><br><span class="line">  origin/bugfix1</span><br><span class="line">  origin/master</span><br><span class="line">localhost:bookstore liaoxb$ git branch -d origin/bugfix1</span><br><span class="line">Deleted remote-tracking branch origin/bugfix1 (was 2eafe98).</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地分支</span></span><br><span class="line">localhost:bookstore liaoxb$ git push origin --delete origin/bugfix1</span><br><span class="line">remote: Powered by GITEE.COM [GNK-3.0]</span><br><span class="line">To https://gitee.com/wisecloud/bookstore.git</span><br><span class="line"> - [deleted]         bugfix1</span><br><span class="line">localhost:bookstore liaoxb$ git branch -r</span><br><span class="line">  origin/HEAD -&gt; origin/master</span><br><span class="line">  origin/master</span><br></pre></td></tr></table></figure>

<h3 id="分支引入错误代码，需要回滚"><a href="#分支引入错误代码，需要回滚" class="headerlink" title="分支引入错误代码，需要回滚"></a>分支引入错误代码，需要回滚</h3><p>回滚至某次commit，之后的所有commit全部会丢失</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset --hard &lt;commit_id&gt;</span><br><span class="line">git push --force</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins集成自动化测试项目</title>
    <url>/2019/03/29/jenkins-ci-autotest/</url>
    <content><![CDATA[<h1 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h1><p>公司项目搭建了一套CICD，每天可以自动地构建镜像并部署至测试环境，此时需要对接自动化测试，实现持续集成测试。</p>
<h1 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -u root -d  --name jenkins-ci -p 8081:8080 -p 50000:50000 -v /etc/localtime:/etc/localtime -v /etc/timezone:/etc/timezone -v jenkins-data:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v $(<span class="built_in">which</span> docker):/usr/bin/docker jenkinsci/blueocean</span><br></pre></td></tr></table></figure>

<p>命令说明：</p>
<p>1、通过 <code>-v $(which docker):/usr/bin/docker</code> 和 <code>-v /var/run/docker.sock:/var/run/docker.sock</code>，容器内可以直接调用宿主机的 Docker命令，从而实现构建、测试等任务。即DooD（Docker-outside-of-Docker）方案</p>
<p>2、如果宿主机不存在timezone文件，自己手动创建并写入Asia&#x2F;Shanghai即可</p>
<p>执行命令截图：</p>
<img src="/2019/03/29/jenkins-ci-autotest/jk01.png" class="" title="jk.png">

<p>为了省心方便，在此默认选择了jenkins推荐的插件安装,这需要耐心等待一段时间：</p>
<img src="/2019/03/29/jenkins-ci-autotest/jk02.png" class="" title="jk.png">

<h1 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h1><h2 id="配置gitlab仓库拉取权限"><a href="#配置gitlab仓库拉取权限" class="headerlink" title="配置gitlab仓库拉取权限"></a><strong>配置gitlab仓库拉取权限</strong></h2><p>1、jenkins容器内生成SSH密钥对</p>
<img src="/2019/03/29/jenkins-ci-autotest/image-20250310002536286.png" class="" title="image-20250310002536286">

<p>2、拷贝SSH公钥至gitlab账号</p>
<img src="/2019/03/29/jenkins-ci-autotest/image-20250310002536300.png" class="" title="image-20250310002536300">

<p>3、Jenkins容器内验证SSH密钥是否已正确添加，参考以下文档</p>
<img src="/2019/03/29/jenkins-ci-autotest/image.png" class="" title="image">

<h2 id="配置邮件服务器"><a href="#配置邮件服务器" class="headerlink" title="配置邮件服务器"></a>配置邮件服务器</h2><p>1、配置发件人邮箱</p>
<img src="/2019/03/29/jenkins-ci-autotest/image-20250309233827675.png" class="" title="image-20250309233827675">

<p>2、jenkins配置smtp服务器</p>
<p>以配置qq邮箱服务器为例（密码填qq邮箱的授权码），测试配置如果发送成功，说明邮件配置成功</p>
<img src="/2019/03/29/jenkins-ci-autotest/jk03.png" class="" title="jk.png">

<h2 id="安装报告插件"><a href="#安装报告插件" class="headerlink" title="安装报告插件"></a>安装报告插件</h2><p>由于项目里的自动化脚本基于RF编写开发，所以Jenkins需要安装robot-framework插件。该插件在Jenkins中收集并发布Robot Framework测试结果。</p>
<h1 id="集成自动化测试项目"><a href="#集成自动化测试项目" class="headerlink" title="集成自动化测试项目"></a>集成自动化测试项目</h1><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>框架搭建时，主要用了以下工具：</p>
<ul>
<li>gitee：管理多分支代码</li>
<li>Robot Framework：作为测试框架</li>
<li>docker：打包测试脚本和python包依赖，构建测试镜像</li>
</ul>
<p>配置数据管理</p>
<ul>
<li>目前是把不同的测试集群信息放在wisecloud.yaml文件里管理，另外basedata.py文件管理其它配置数据。比如公共登录账号、harbor地址账号等。</li>
<li>配置读取：单独创建一个Rest类，并继承REST父类。get_baseurl实例方法会根据env_type变量值，去动态获取目标集群的访问地址、集群ip地址,并调用BuiltIn().set_global_variable方法去设为全局变量。供用例执行过程中使用</li>
</ul>
<p>分层设计与解耦</p>
<ul>
<li><p>用例、方法（关键字）、测试库分层</p>
</li>
<li><p>用例按模块划分成多个测试用例文件，集中放进测试套件Suites</p>
</li>
<li><p>方法按模块划分成多个资源文件，集中放进资源文件夹Resource</p>
</li>
<li><p>自定义创建测试库和方法，集中放进Library。以关键字的形式以供调用</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">├── Library</span><br><span class="line">│   ├── Basedata.py</span><br><span class="line">│   ├── Rest.py</span><br><span class="line">│   ├── ServiceAdd.py</span><br><span class="line">│   └── wisecloud.yaml</span><br><span class="line">├── Resource</span><br><span class="line">│   ├── BackupRestore.robot</span><br><span class="line">│   ├── Common.robot</span><br><span class="line">│   ├── Configcenter.robot</span><br><span class="line">│   ├── Dashboard.robot</span><br><span class="line">│   ├── Monitor.robot</span><br><span class="line">│   ├── Orche_App.robot</span><br><span class="line">│   ├── Orche_Stack.robot</span><br><span class="line">│   ├── Resource_Manager.robot</span><br><span class="line">│   ├── Workflow.robot</span><br><span class="line">│   └── pipeline_workflow.robot</span><br><span class="line">├── Suites</span><br><span class="line">│   ├── backuprestore.robot</span><br><span class="line">│   ├── configcenter.robot</span><br><span class="line">│   ├── dashboard.robot</span><br><span class="line">│   ├── ingress</span><br><span class="line">│   │   └── ingress.robot</span><br></pre></td></tr></table></figure>


<h2 id="编写Pipeline脚本"><a href="#编写Pipeline脚本" class="headerlink" title="编写Pipeline脚本"></a>编写Pipeline脚本</h2><p>直接贴脚本，pipeline支持的语法可查看官方手册。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    options &#123;</span><br><span class="line">        // 添加日志打印时间</span><br><span class="line">        timestamps()</span><br><span class="line">        // 设置全局超时间</span><br><span class="line">        // timeout(time:10,unit:&#x27;MINUTES&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    environment &#123;</span><br><span class="line">        // GIT_BRANCH = &#x27;master&#x27; # 已设置全局变量</span><br><span class="line">        GIT_USER_ID = &#x27;76f84542-2dba-4128-8651-bed7a849eddd&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Git Clone&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                // sh  &#x27;printenv |sort&#x27;</span><br><span class="line">                git branch: &quot;$&#123;GIT_BRANCH&#125;&quot;, credentialsId: &quot;$&#123;GIT_USER_ID&#125;&quot;, url: &#x27;https://gitee.com/wisecloud/wise2c-robot.git&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;Build Image&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;docker build -t $&#123;JOB_NAME&#125;:$&#123;GIT_BRANCH&#125; .&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;API Test&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script&#123;</span><br><span class="line">                    sh &#x27;ls -a&#x27;</span><br><span class="line">                    sh &#x27;docker run --rm -v jenkins-data:/robot-results --name $&#123;JOB_NAME&#125; $&#123;JOB_NAME&#125;:$&#123;GIT_BRANCH&#125; robot --outputdir /robot-results /wise2c-robot/Project/Suites/resource_manager.robot&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123;</span><br><span class="line">        always &#123;</span><br><span class="line">            echo &#x27;Publish Test Report&#x27;</span><br><span class="line">            robot logFileName: &#x27;log.html&#x27;, outputFileName: &#x27;output.xml&#x27;, outputPath: &#x27;/var/jenkins_home/&#x27;, passThreshold: 100.0, reportFileName: &#x27;report.html&#x27;, unstableThreshold: 90.0</span><br><span class="line">            // deleteDir() /* clean up our workspace */</span><br><span class="line">        &#125;</span><br><span class="line">        success &#123;</span><br><span class="line">            mail bcc: &#x27;&#x27;, body: &quot;API自动化测试通过\n测试版本分支：$&#123;GIT_BRANCH&#125;\n测试报告地址：$&#123;BUILD_URL&#125;&quot;, cc: &#x27;&#x27;, from: &#x27;1219199895@qq.com&#x27;, replyTo: &#x27;&#x27;, subject: &quot;$&#123;JOB_NAME&#125;测试报告&quot;, to: &#x27;liaoxb@wise2c.com&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        failure &#123;</span><br><span class="line">            mail bcc: &#x27;&#x27;, body: &quot;API自动化测试未通过，请相关模块的同事分析定位问题，谢谢大家。\n测试版本分支：$&#123;GIT_BRANCH&#125;\n测试报告地址：$&#123;BUILD_URL&#125;&quot;, cc: &#x27;&#x27;, from: &#x27;1219199895@qq.com&#x27;, replyTo: &#x27;&#x27;, subject: &quot;$&#123;JOB_NAME&#125;测试报告&quot;, to: &#x27;liaoxb@wise2c.com&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="webhook触发流水线"><a href="#webhook触发流水线" class="headerlink" title="webhook触发流水线"></a>webhook触发流水线</h2><p>1、新建pipeline时，构建触发器选择‘触发远程构建’这项，输入token name。比如apitest<br>这时就可以获得一个webhhok地址，提供给维护CICD平台的同事即可。<br>2、把pipeline脚本内容粘贴到流水线里，检查下有没有语法错误，最后点击保存<br>3、现在可以用curl模拟发送一次webhhok请求，不过记得临时把全局安全配置里的授权策略给放开，改成没有任何限制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl JENKINS_URL/job/wise2c-robot/build?token=TOKEN_NAME</span><br></pre></td></tr></table></figure>



<img src="/2019/03/29/jenkins-ci-autotest/jk05.png" class="" title="jk.png">

<h2 id="测试结果报告展示"><a href="#测试结果报告展示" class="headerlink" title="测试结果报告展示"></a>测试结果报告展示</h2><p>job首页测试结果展示，失败了1条case，同时收到了一封关于api测试失败的邮件通知：</p>
<img src="/2019/03/29/jenkins-ci-autotest/jk04.png" class="" title="jk.png">
<img src="/2019/03/29/jenkins-ci-autotest/jk07.png" class="" title="jk.png">

<p>测试结果详情页面展示，点击log.html链接可以直接查看日志；</p>
<img src="/2019/03/29/jenkins-ci-autotest/jk06.png" class="" title="jk.png">
<img src="/2019/03/29/jenkins-ci-autotest/jk08.png" class="" title="jk.png">

<p>如果到打开失败，可以参考这个解决办法。<a href="https://stackoverflow.com/questions/36607394/error-opening-robot-framework-log-failed">https://stackoverflow.com/questions/36607394/error-opening-robot-framework-log-failed</a><br>管理jenkins–&gt;脚本命令行输入如下脚本:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.setProperty(&quot;hudson.model.DirectoryBrowserSupport.CSP&quot;,&quot;sandbox allow-scripts; default-src &#x27;none&#x27;; img-src &#x27;self&#x27; data: ; style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; data: ; script-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; &#x27;unsafe-eval&#x27; ;&quot;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>测试自动化</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>Robot Framework</tag>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes系列：监控组件部署</title>
    <url>/2019/03/04/kubernetes_monitor/</url>
    <content><![CDATA[<p>在实际工作中，通过prometheus监控的主要对象有如下几个：</p>
<ul>
<li>基础设施层：主要是监控k8s节点资源，如CPU,内存,网络吞吐和带宽占用,磁盘I&#x2F;O和磁盘使用等指标；</li>
<li>中间件层：监控产品使用到的中间件（一般会独立部署在外部集群），主要有consul、mysql、nats、redis、haproxy</li>
<li>Kubernetes集群：监控Kubernetes集群本身的关键指标</li>
<li>Kubernetes集群上部署的应用：监控部署在Kubernetes集群上的应用（pod或container等）</li>
</ul>
<p>Step By Step，部署工作正式开始！</p>
<h3 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h3><p>操作系统环境：centos linux 7.4 64bit</p>
<p>K8S软件版本： v1.8.6</p>
<p>Master节点IP： 192.168.1.111&#x2F;24</p>
<p>Node节点IP： 192.168.1.155&#x2F;24 192.168.1.251&#x2F;24</p>
<h3 id="采用daemonset方式部署node-exporter组件"><a href="#采用daemonset方式部署node-exporter组件" class="headerlink" title="采用daemonset方式部署node-exporter组件"></a>采用daemonset方式部署node-exporter组件</h3><h4 id="部署node-exporter-yaml文件"><a href="#部署node-exporter-yaml文件" class="headerlink" title="部署node-exporter.yaml文件"></a>部署node-exporter.yaml文件</h4><p>节点上默认暴露9100端口，通过hostip:9100即可访问node-exporter的metrics</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat node-exporter.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">node-exporter</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">prometheus.io/scrape:</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">9100</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">node-exporter</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">updateStrategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">node-exporter</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">prom/node-exporter:v0.16.0</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9100</span></span><br><span class="line">          <span class="attr">hostPort:</span> <span class="number">9100</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">local-timezone</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">&quot;/etc/localtime&quot;</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;node-role.kubernetes.io/master&quot;</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">&quot;Exists&quot;</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">&quot;NoSchedule&quot;</span></span><br><span class="line">      <span class="attr">hostPID:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">local-timezone</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/etc/localtime</span></span><br></pre></td></tr></table></figure>

<h4 id="部署成功截图："><a href="#部署成功截图：" class="headerlink" title="部署成功截图："></a>部署成功截图：</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@test--0005 liaoxb]# kubectl create -f node-exporter.yaml</span><br><span class="line">service <span class="string">&quot;node-exporter&quot;</span> created</span><br><span class="line">daemonset <span class="string">&quot;node-exporter&quot;</span> created</span><br><span class="line">[root@test--0005 liaoxb]# kcs get pods -o wide</span><br><span class="line">NAME                                  READY     STATUS    RESTARTS   AGE       IP              NODE</span><br><span class="line">kube-apiserver-test--0005             1/1       Running   0          5d        192.168.1.111   test--0005</span><br><span class="line">kube-controller-manager-test--0005    1/1       Running   0          5d        192.168.1.111   test--0005</span><br><span class="line">kube-dns-5cfc95db9f-qxk55             3/3       Running   0          5d        10.244.0.62     test--0005</span><br><span class="line">kube-flannel-ds-48xfp                 1/1       Running   0          5d        192.168.1.155   test--0006</span><br><span class="line">kube-flannel-ds-d84t5                 1/1       Running   0          5d        192.168.1.251   test--0007</span><br><span class="line">kube-flannel-ds-nm8xl                 1/1       Running   0          5d        192.168.1.111   test--0005</span><br><span class="line">kube-proxy-dxxd7                      1/1       Running   0          5d        192.168.1.155   test--0006</span><br><span class="line">kube-proxy-hfzlf                      1/1       Running   0          5d        192.168.1.251   test--0007</span><br><span class="line">kube-proxy-zw8qr                      1/1       Running   0          5d        192.168.1.111   test--0005</span><br><span class="line">kube-scheduler-test--0005             1/1       Running   0          5d        192.168.1.111   test--0005</span><br><span class="line">kubernetes-dashboard-d8b49876-2l2gx   1/1       Running   0          5d        10.244.0.63     test--0005</span><br><span class="line">node-exporter-dzsq7                   1/1       Running   0          46s       192.168.1.155   test--0006</span><br><span class="line">node-exporter-mkxrd                   1/1       Running   0          46s       192.168.1.111   test--0005</span><br><span class="line">node-exporter-s8xw2                   1/1       Running   0          46s       192.168.1.251   test--0007</span><br><span class="line">tiller-69ccbb4f7f-6dbsg               1/1       Running   0          4d        192.168.1.155   test--0006</span><br><span class="line">[root@test--0005 liaoxb]# kcs get svc -o wide |grep node-exporter</span><br><span class="line">node-exporter          ClusterIP   10.105.53.97    &lt;none&gt;        9100/TCP        1m        app=node-exporter</span><br></pre></td></tr></table></figure>

<h3 id="部署prometheus组件"><a href="#部署prometheus组件" class="headerlink" title="部署prometheus组件"></a>部署prometheus组件</h3><h4 id="部署rbac文件"><a href="#部署rbac文件" class="headerlink" title="部署rbac文件"></a>部署rbac文件</h4><p>prometheus-rbac.yml定义了Prometheus容器访问k8s apiserver所需的ServiceAccount和ClusterRole及ClusterRoleBinding</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat prometheus-rbac.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">nodes</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">nodes/proxy</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">services</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">endpoints</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pods</span></span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]</span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">extensions</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ingresses</span></span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]</span><br><span class="line"><span class="bullet">-</span> <span class="attr">nonResourceURLs:</span> [<span class="string">&quot;/metrics&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>]</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure>



<h4 id="部署prometheus的配置文件configmap"><a href="#部署prometheus的配置文件configmap" class="headerlink" title="部署prometheus的配置文件configmap"></a>部署prometheus的配置文件configmap</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cat prometheus-cm.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">prometheus.yml:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    global:</span></span><br><span class="line"><span class="string">      scrape_interval:     15s</span></span><br><span class="line"><span class="string">      evaluation_interval: 15s</span></span><br><span class="line"><span class="string">    scrape_configs:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;kubernetes-apiservers-567&#x27;</span></span><br><span class="line">      <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">endpoints</span></span><br><span class="line">      <span class="attr">scheme:</span> <span class="string">https</span></span><br><span class="line">      <span class="attr">tls_config:</span></span><br><span class="line">        <span class="attr">ca_file:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span></span><br><span class="line">      <span class="attr">bearer_token_file:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount/token</span></span><br><span class="line">      <span class="attr">relabel_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_namespace</span>, <span class="string">__meta_kubernetes_service_name</span>, <span class="string">__meta_kubernetes_endpoint_port_name</span>]</span><br><span class="line">        <span class="attr">action:</span> <span class="string">keep</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">default;kubernetes;https</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;kubernetes-cadvisor-567&#x27;</span></span><br><span class="line">      <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">node</span></span><br><span class="line">      <span class="attr">scheme:</span> <span class="string">https</span></span><br><span class="line">      <span class="attr">tls_config:</span></span><br><span class="line">        <span class="attr">ca_file:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span></span><br><span class="line">      <span class="attr">bearer_token_file:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount/token</span></span><br><span class="line">      <span class="attr">relabel_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">labelmap</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">__meta_kubernetes_node_label_(.+)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">target_label:</span> <span class="string">__address__</span></span><br><span class="line">        <span class="attr">replacement:</span> <span class="string">kubernetes.default.svc:443</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_node_name</span>]</span><br><span class="line">        <span class="attr">regex:</span> <span class="string">(.+)</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">__metrics_path__</span></span><br><span class="line">        <span class="attr">replacement:</span> <span class="string">/api/v1/nodes/$&#123;1&#125;/proxy/metrics/cadvisor</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;kubernetes-nodes-567&#x27;</span></span><br><span class="line">      <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">endpoints</span></span><br><span class="line">      <span class="attr">relabel_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_service_annotation_prometheus_io_scrape</span>]</span><br><span class="line">        <span class="attr">action:</span> <span class="string">keep</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_service_annotation_prometheus_io_scheme</span>]</span><br><span class="line">        <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">__scheme__</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">(https?)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_service_annotation_prometheus_io_path</span>]</span><br><span class="line">        <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">__metrics_path__</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">(.+)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__address__</span>, <span class="string">__meta_kubernetes_service_annotation_prometheus_io_port</span>]</span><br><span class="line">        <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">__address__</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">([^:]+)(?::\d+)?;(\d+)</span></span><br><span class="line">        <span class="attr">replacement:</span> <span class="string">$1:$2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">labelmap</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">__meta_kubernetes_service_label_(.+)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_namespace</span>]</span><br><span class="line">        <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">kubernetes_namespace</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_service_name</span>]</span><br><span class="line">        <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">kubernetes_name</span></span><br></pre></td></tr></table></figure>

<h4 id="部署Prometheus-deployment-文件"><a href="#部署Prometheus-deployment-文件" class="headerlink" title="部署Prometheus deployment 文件"></a>部署Prometheus deployment 文件</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat prometheus-deploy.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">prometheus-deployment</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">prom/prometheus:v2.7.1</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;/bin/prometheus&quot;</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;--config.file=/etc/prometheus/prometheus.yml&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;--storage.tsdb.path=/prometheus&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;--storage.tsdb.retention=24h&quot;</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9090</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">&quot;/prometheus&quot;</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">&quot;/etc/prometheus&quot;</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">500m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">2500Mi</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">prometheus</span></span><br><span class="line">      <span class="attr">imagePullSecrets:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">regsecret</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">           <span class="attr">path:</span> <span class="string">/prometheus</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">prometheus-config</span></span><br></pre></td></tr></table></figure>

<h4 id="部署Prometheus-svc-文件"><a href="#部署Prometheus-svc-文件" class="headerlink" title="部署Prometheus svc 文件"></a>部署Prometheus svc 文件</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cat prometheus-svc.yaml</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">9090</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">9090</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">32002</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">prometheus</span></span><br></pre></td></tr></table></figure>

<h4 id="部署成功截图：-1"><a href="#部署成功截图：-1" class="headerlink" title="部署成功截图："></a>部署成功截图：</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@test--0005 liaoxb]# kubectl create -f prometheus-rbac.yaml</span><br><span class="line">clusterrole <span class="string">&quot;prometheus&quot;</span> created</span><br><span class="line">serviceaccount <span class="string">&quot;prometheus&quot;</span> created</span><br><span class="line">clusterrolebinding <span class="string">&quot;prometheus&quot;</span> created</span><br><span class="line">[root@test--0005 liaoxb]# kubectl create -f prometheus-cm.yaml</span><br><span class="line">configmap <span class="string">&quot;prometheus-config&quot;</span> created</span><br><span class="line">[root@test--0005 liaoxb]# kubectl create -f prometheus-deploy.yaml</span><br><span class="line">deployment <span class="string">&quot;prometheus&quot;</span> created</span><br><span class="line">[root@test--0005 liaoxb]# kubectl create -f prometheus-svc.yaml</span><br><span class="line">service <span class="string">&quot;prometheus&quot;</span> created</span><br><span class="line">[root@test--0005 liaoxb]# kcs get pods -o wide |grep prometheus</span><br><span class="line">prometheus-78c8788f44-cmt9g           1/1       Running   0          32s       10.244.2.32     test--0007</span><br></pre></td></tr></table></figure>

<p>通过prometheus节点加上nodeport即可访问prometheus web页面，target页面可看见prometheus已经成功连接上监控的job；此时prometheus就可以拉取并存储每个job采集的时序数据，Graph界面上提供了基本的查询K8S集群中每个POD的CPU使用情况，PromQL查询条件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum by (pod_name)( rate(container_cpu_usage_seconds_total&#123;image!=&quot;&quot;, pod_name!=&quot;&quot;&#125;[1m] ) )</span><br></pre></td></tr></table></figure>



<blockquote>
<p>prometheus节点ip:32002访问prometheus ui</p>
</blockquote>
<img src="/2019/03/04/kubernetes_monitor/image1.png" class="" title="image">

<blockquote>
<p>PromQL查询数据</p>
</blockquote>
<img src="/2019/03/04/kubernetes_monitor/image2.png" class="" title="image">

<h3 id="部署Grafana组件"><a href="#部署Grafana组件" class="headerlink" title="部署Grafana组件"></a>部署Grafana组件</h3><h4 id="部署grafana-yaml"><a href="#部署grafana-yaml" class="headerlink" title="部署grafana.yaml"></a>部署grafana.yaml</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cat grafana.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">3000</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">32003</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">grafana</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">grafana</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">grafana</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">grafana/grafana:4.2.0</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3000</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GF_AUTH_BASIC_ENABLED</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GF_AUTH_ANONYMOUS_ENABLED</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">[<span class="string">root@test--0005</span> <span class="string">liaoxb</span>]<span class="comment"># kubectl create -f grafana.yaml</span></span><br><span class="line"><span class="string">service</span> <span class="string">&quot;grafana&quot;</span> <span class="string">created</span></span><br><span class="line"><span class="string">deployment</span> <span class="string">&quot;grafana&quot;</span> <span class="string">created</span></span><br><span class="line">[<span class="string">root@test--0005</span> <span class="string">liaoxb</span>]<span class="comment"># kcs get pods -o wide |grep grafana</span></span><br><span class="line"><span class="string">grafana-f9f5975f8-mv74b</span>               <span class="number">1</span><span class="string">/1</span>       <span class="string">Running</span>   <span class="number">0</span>          <span class="string">24s</span>       <span class="number">10.244</span><span class="number">.1</span><span class="number">.32</span>     <span class="string">test--0006</span></span><br><span class="line">[<span class="string">root@test--0005</span> <span class="string">liaoxb</span>]<span class="comment"># kcs get svc -o wide |grep grafana</span></span><br><span class="line"><span class="string">grafana</span>                <span class="string">NodePort</span>    <span class="number">10.102</span><span class="number">.160</span><span class="number">.34</span>    <span class="string">&lt;none&gt;</span>        <span class="number">3000</span><span class="string">:32003/TCP</span>   <span class="string">42s</span>       <span class="string">app=grafana</span></span><br></pre></td></tr></table></figure>

<p>此时就可以通过grafana节点ip:32003访问grafana web页面，账户密码默认都是admin；</p>
<h4 id="grafana配置数据源为prometheus"><a href="#grafana配置数据源为prometheus" class="headerlink" title="grafana配置数据源为prometheus"></a>grafana配置数据源为prometheus</h4><img src="/2019/03/04/kubernetes_monitor/image3.png" class="" title="image">

<h4 id="导入监控Dashboard"><a href="#导入监控Dashboard" class="headerlink" title="导入监控Dashboard"></a>导入监控Dashboard</h4><p>使用<a href="https://grafana.com/dashboards/162">Kubernetes cluster monitoring (via Prometheus)</a>这个即可</p>
<img src="/2019/03/04/kubernetes_monitor/image4.png" class="" title="image">

<h4 id="Dashboard数据展示"><a href="#Dashboard数据展示" class="headerlink" title="Dashboard数据展示"></a>Dashboard数据展示</h4><blockquote>
<p>主机监控数据展示</p>
</blockquote>
<img src="/2019/03/04/kubernetes_monitor/image5.png" class="" title="image">

<blockquote>
<p>pod和container数据展示</p>
</blockquote>
<img src="/2019/03/04/kubernetes_monitor/image6.png" class="" title="image">

<h3 id="Kubernetes集群上部署应用的监控"><a href="#Kubernetes集群上部署应用的监控" class="headerlink" title="Kubernetes集群上部署应用的监控"></a>Kubernetes集群上部署应用的监控</h3><p>Kubernetes集群上Pod, DaemonSet, Deployment, Job, CronJob等各种资源对象的状态需要监控，这也反映了使用这些资源部署的应用的状态。但通过查看前面Prometheus从k8s集群拉取的指标(这些指标主要来自apiserver和kubelet中集成的cAdvisor)，并没有具体的各种资源对象的状态指标。对于Prometheus来说，当然是需要引入新的exporter来暴露这些指标，Kubernetes提供了一个kube-state-metrics正式我们需要。</p>
<h4 id="在Kubernetes上部署kube-state-metrics组件"><a href="#在Kubernetes上部署kube-state-metrics组件" class="headerlink" title="在Kubernetes上部署kube-state-metrics组件"></a>在Kubernetes上部署kube-state-metrics组件</h4><p><a href="https://github.com/kubernetes/kube-state-metrics.git">https://github.com/kubernetes/kube-state-metrics.git</a></p>
<p>kube-state-metrics&#x2F;kubernetes目录下，有所需要的文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@test--0005 liaoxb]# kubectl create -f kube-state-metrics/kubernetes/</span><br><span class="line">clusterrolebinding <span class="string">&quot;kube-state-metrics&quot;</span> created</span><br><span class="line">clusterrole <span class="string">&quot;kube-state-metrics&quot;</span> created</span><br><span class="line">deployment <span class="string">&quot;kube-state-metrics&quot;</span> created</span><br><span class="line">rolebinding <span class="string">&quot;kube-state-metrics&quot;</span> created</span><br><span class="line">role <span class="string">&quot;kube-state-metrics-resizer&quot;</span> created</span><br><span class="line">serviceaccount <span class="string">&quot;kube-state-metrics&quot;</span> created</span><br><span class="line">service <span class="string">&quot;kube-state-metrics&quot;</span> created</span><br></pre></td></tr></table></figure>



<p>将kube-state-metrics部署到Kubernetes上之后，就会发现Kubernetes集群中的Prometheus会在kubernetes-nodes-567这个job下自动服务发现kube-state-metrics，并开始拉取metrics。这是因为prometheus-cm.yml中Prometheus的配置文件job kubernetes-nodes-567的配置。而部署kube-state-metrics的定义文件kube-state-metrics-service.yaml对kube-state-metrics Service的定义包含annotation prometheus.io&#x2F;scrape: ‘true’，因此kube-state-metrics的endpoint可以被Prometheus自动服务发现</p>
<blockquote>
<p>查询k8s集群中deploy的个数：</p>
</blockquote>
<img src="/2019/03/04/kubernetes_monitor/image7.png" class="" title="image">

<h3 id="中间件监控"><a href="#中间件监控" class="headerlink" title="中间件监控"></a>中间件监控</h3><p>关于中间件的exporter部署请自行在prometheus项目中查找<br><a href="https://github.com/prometheus">https://github.com/prometheus</a><br>最主要的关键点是配置好prometheus.yml文件，在configmap中追加如下格式内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">consul</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">30s</span></span><br><span class="line">  <span class="attr">scrape_timeout:</span> <span class="string">30s</span></span><br><span class="line">  <span class="attr">metrics_path:</span> <span class="string">/metrics</span></span><br><span class="line">  <span class="attr">scheme:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.111</span><span class="string">:9107</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.155</span><span class="string">:9107</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.251</span><span class="string">:9107</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">haproxy</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">30s</span></span><br><span class="line">  <span class="attr">scrape_timeout:</span> <span class="string">30s</span></span><br><span class="line">  <span class="attr">metrics_path:</span> <span class="string">/metrics</span></span><br><span class="line">  <span class="attr">scheme:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.111</span><span class="string">:9101</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">30s</span></span><br><span class="line">  <span class="attr">scrape_timeout:</span> <span class="string">30s</span></span><br><span class="line">  <span class="attr">metrics_path:</span> <span class="string">/metrics</span></span><br><span class="line">  <span class="attr">scheme:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.111</span><span class="string">:9104</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.155</span><span class="string">:9104</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.251</span><span class="string">:9104</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">nats</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">30s</span></span><br><span class="line">  <span class="attr">scrape_timeout:</span> <span class="string">30s</span></span><br><span class="line">  <span class="attr">metrics_path:</span> <span class="string">/metrics</span></span><br><span class="line">  <span class="attr">scheme:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.111</span><span class="string">:7777</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.155</span><span class="string">:7777</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.251</span><span class="string">:7777</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">30s</span></span><br><span class="line">  <span class="attr">scrape_timeout:</span> <span class="string">30s</span></span><br><span class="line">  <span class="attr">metrics_path:</span> <span class="string">/metrics</span></span><br><span class="line">  <span class="attr">scheme:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.155</span><span class="string">:9121</span></span><br></pre></td></tr></table></figure>

<p>prometheus-cm.yaml里job追加配置成功后，需要kubectl apply -f prometheus-cm.yaml，并且重启prometheus实例；重启成功后在target页面就可以看见新增加的中间件job采集项。</p>
<blockquote>
<p>consul haproxy等中间件采集job</p>
</blockquote>
<img src="/2019/03/04/kubernetes_monitor/image8.png" class="" title="image">

<p>部署实践小结：</p>
<ul>
<li>至此，我们就能通过grafana能够展示基础设施层、Kubernetes集群自身的监控数据指标，比如cpu、内存、网络IO等（数据采集组件分别是node-exporter、cadvisor）</li>
<li>Kubernetes集群上部署应用的监控，尤其是对应用状态的监控，主要是采用kube-state-metrics组件的指标，这是对以上组件很好的补充</li>
<li>中间件监控，主要是部署各自的exporter容器，暴露固定端口以供prometheus拉取监控metrics数据</li>
</ul>
<p>参考链接：</p>
<p><a href="https://www.kubernetes.org.cn/3418.html">https://www.kubernetes.org.cn/3418.html</a></p>
<p><a href="https://github.com/prometheus">https://github.com/prometheus</a></p>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>Prometheus</tag>
        <tag>Grafana</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes系列：kubeadm部署K8S集群v1.16.4</title>
    <url>/2019/12/01/kubernetes_deploy/</url>
    <content><![CDATA[<h1 id="环境准备工作"><a href="#环境准备工作" class="headerlink" title="环境准备工作"></a>环境准备工作</h1><h2 id="环境角色"><a href="#环境角色" class="headerlink" title="环境角色"></a>环境角色</h2><table>
<thead>
<tr>
<th>IP</th>
<th>角色</th>
<th>软件安装</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.0.16</td>
<td>K8S Master</td>
<td>kube-apiserver kube-schduler kube-controller-manager kube-proxy docker flannel kubelet etcd</td>
</tr>
<tr>
<td>192.168.0.17</td>
<td>K8s Node</td>
<td>kubelet kube-proxy docker flannel</td>
</tr>
<tr>
<td>192.168.0.18</td>
<td>K8s Node</td>
<td>kubelet kube-proxy docker flannel</td>
</tr>
</tbody></table>
<blockquote>
<p>以下所有1.x操作,在三台节点都执行</p>
</blockquote>
<h2 id="统一设置主机名"><a href="#统一设置主机名" class="headerlink" title="统一设置主机名"></a>统一设置主机名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hostnamectl set-hostname test01</span><br><span class="line">$ hostnamectl set-hostname test02</span><br><span class="line">$ hostnamectl set-hostname test03</span><br></pre></td></tr></table></figure>

<h2 id="部署机免密登录到test01、test02、test03"><a href="#部署机免密登录到test01、test02、test03" class="headerlink" title="部署机免密登录到test01、test02、test03"></a>部署机免密登录到test01、test02、test03</h2><blockquote>
<p>前提是目标主机需要生成公钥以及密钥 ssh-keygen -t rsa</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@harbor ~]# ssh-copy-id -i ~/.ssh/id_rsa.pub root@test02</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;/root/.ssh/id_rsa.pub&quot;</span><br><span class="line">The authenticity of host &#x27;test02 (192.168.0.17)&#x27; can&#x27;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:Omg7RAlyXPvDcwNyJdufEmAMHnwcS3eh/gsaHPZVP6I.</span><br><span class="line">ECDSA key fingerprint is MD5:5d:55:0f:b2:75:4d:39:ee:47:c1:a8:3f:0f:12:96:30.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span><br><span class="line">root@test02&#x27;s password:</span><br><span class="line"></span><br><span class="line">Number of key(s) added: 1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with:   &quot;ssh &#x27;root@test02&#x27;&quot;</span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br></pre></td></tr></table></figure>



<h2 id="关闭防火墙及selinux"><a href="#关闭防火墙及selinux" class="headerlink" title="关闭防火墙及selinux"></a>关闭防火墙及selinux</h2><blockquote>
<p>docker selinux-enabled作用和原理看介绍</p>
</blockquote>
<p><a href="https://www.cnblogs.com/elnino/p/10845449.html">https://www.cnblogs.com/elnino/p/10845449.html</a></p>
<blockquote>
<p>防火墙的文档介绍</p>
</blockquote>
<p><a href="https://wangchujiang.com/linux-command/c/firewall-cmd.html">https://wangchujiang.com/linux-command/c/firewall-cmd.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 关闭selinux</span><br><span class="line">$ systemctl stop firewalld &amp;&amp; systemctl disable firewalld</span><br><span class="line">$ sed -i --follow-symlinks &#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27; /etc/sysconfig/selinux &amp;&amp; setenforce 0</span><br><span class="line"># 关闭防火墙</span><br><span class="line">[root@test01 ~]# systemctl start firewalld</span><br><span class="line">[root@test01 ~]# firewall-cmd --set-default-zone=trusted</span><br><span class="line">success</span><br><span class="line">[root@test01 ~]# firewall-cmd --complete-reload</span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<h2 id="关闭-swap-分区"><a href="#关闭-swap-分区" class="headerlink" title="关闭 swap 分区"></a>关闭 swap 分区</h2><blockquote>
<p>对于禁用swap内存，具体原因可以查看Github上的Issue：<a href="https://github.com/kubernetes/kubernetes/issues/53533">https://github.com/kubernetes/kubernetes/issues/53533</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ swapoff -a # 临时</span><br><span class="line">$ sed -i &#x27;/ swap / s/^\(.*\)$/#\1/g&#x27; /etc/fstab #永久</span><br></pre></td></tr></table></figure>

<h2 id="内核调整-将桥接的IPv4流量传递到iptables的链"><a href="#内核调整-将桥接的IPv4流量传递到iptables的链" class="headerlink" title="内核调整,将桥接的IPv4流量传递到iptables的链"></a>内核调整,将桥接的IPv4流量传递到iptables的链</h2><blockquote>
<p><a href="https://kubernetes.io/zh/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/">https://kubernetes.io/zh/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开启Linux的路由转发功能:</span><br><span class="line">sysctl -w net.ipv4.ip_forward=1</span><br><span class="line"></span><br><span class="line">cni插件确保简单的配置（如带网桥的 Docker ）与 iptables 代理正常工作:</span><br><span class="line">sysctl -w net.bridge.bridge-nf-call-iptables=1</span><br><span class="line">sysctl -w net.bridge.bridge-nf-call-ip6tables=1</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@test01 ~]# cat /proc/sys/net/ipv4/ip_forward</span><br><span class="line">1</span><br><span class="line">[root@test01 ~]# cat /proc/sys/net/bridge/bridge-nf-call-iptables</span><br><span class="line">1</span><br><span class="line">[root@test01 ~]# cat /proc/sys/net/bridge/bridge-nf-call-ip6tables</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="设置系统时区并同步时间服务器"><a href="#设置系统时区并同步时间服务器" class="headerlink" title="设置系统时区并同步时间服务器"></a>设置系统时区并同步时间服务器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ yum install -y ntpdate</span><br><span class="line">$ ntpdate time.windows.com</span><br></pre></td></tr></table></figure>

<h1 id="安装dokcer"><a href="#安装dokcer" class="headerlink" title="安装dokcer"></a>安装dokcer</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@test01 ~]# yum install docker -y</span><br><span class="line">[root@test01 ~]# systemctl enable docker</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.</span><br><span class="line">[root@test01 ~]# systemctl start docker</span><br><span class="line">[root@test01 ~]# docker --version</span><br><span class="line">Docker version 1.13.1, build 4ef4b30/1.13.1</span><br></pre></td></tr></table></figure>

<h1 id="安装K8s"><a href="#安装K8s" class="headerlink" title="安装K8s"></a>安装K8s</h1><h2 id="添加kubernetes-YUM软件源"><a href="#添加kubernetes-YUM软件源" class="headerlink" title="添加kubernetes YUM软件源"></a>添加kubernetes YUM软件源</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h2 id="安装kubeadm-kubelet和kubectl"><a href="#安装kubeadm-kubelet和kubectl" class="headerlink" title="安装kubeadm,kubelet和kubectl"></a>安装kubeadm,kubelet和kubectl</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ yum install -y kubelet-1.16.4 kubeadm-1.16.4 kubectl-1.16.4</span><br><span class="line">$ systemctl enable kubelet</span><br></pre></td></tr></table></figure>

<h2 id="部署Kubernetes-Master"><a href="#部署Kubernetes-Master" class="headerlink" title="部署Kubernetes Master"></a>部署Kubernetes Master</h2><blockquote>
<p>只需要在Master 节点执行，这里的apiserver需要修改成自己的master地址。<br>由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@test01 ~]# kubeadm init --apiserver-advertise-address=192.168.0.16 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.16.4 --service-cidr=10.1.0.0/16 --pod-network-cidr=10.244.0.0/16</span><br><span class="line">[init] Using Kubernetes version: v1.16.4</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">	[WARNING Firewalld]: firewalld is active, please ensure ports [6443 10250] are open or your cluster may not function correctly</span><br><span class="line">	[WARNING Hostname]: hostname &quot;test01&quot; could not be reached</span><br><span class="line">	[WARNING Hostname]: hostname &quot;test01&quot;: lookup test01 on 10.16.140.4:53: no such host</span><br><span class="line">[preflight] Pulling images required for setting up a Kubernetes cluster</span><br><span class="line">[preflight] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight] You can also perform this action in beforehand using &#x27;kubeadm config images pull&#x27;</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[kubelet-start] Activating the kubelet service</span><br><span class="line">[certs] Using certificateDir folder &quot;/etc/kubernetes/pki&quot;</span><br><span class="line">[certs] Generating &quot;ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;apiserver&quot; certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed for DNS names [test01 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.1.0.1 192.168.0.16]</span><br><span class="line">[certs] Generating &quot;apiserver-kubelet-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;front-proxy-ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;front-proxy-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;etcd/ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;etcd/server&quot; certificate and key</span><br><span class="line">[certs] etcd/server serving cert is signed for DNS names [test01 localhost] and IPs [192.168.0.16 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating &quot;etcd/peer&quot; certificate and key</span><br><span class="line">[certs] etcd/peer serving cert is signed for DNS names [test01 localhost] and IPs [192.168.0.16 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating &quot;etcd/healthcheck-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;apiserver-etcd-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;sa&quot; key and public key</span><br><span class="line">[kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot;</span><br><span class="line">[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file</span><br><span class="line">[control-plane] Using manifest folder &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;</span><br><span class="line">[etcd] Creating static Pod manifest for local etcd in &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;/etc/kubernetes/manifests&quot;. This can take up to 4m0s</span><br><span class="line">[apiclient] All control plane components are healthy after 33.002262 seconds</span><br><span class="line">[upload-config] Storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace</span><br><span class="line">[kubelet] Creating a ConfigMap &quot;kubelet-config-1.16&quot; in namespace kube-system with the configuration for the kubelets in the cluster</span><br><span class="line">[upload-certs] Skipping phase. Please see --upload-certs1</span><br><span class="line">[mark-control-plane] Marking the node test01 as control-plane by adding the label &quot;node-role.kubernetes.io/master=&#x27;&#x27;&quot;</span><br><span class="line">[mark-control-plane] Marking the node test01 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]</span><br><span class="line">[bootstrap-token] Using token: 7e169l.60ykxxr8md7sb8ak</span><br><span class="line">[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster</span><br><span class="line">[bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.0.16:6443 --token 7e169l.60ykxxr8md7sb8ak \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:c0b04a34ac7bb55fdf5b04a70233c14c15a11341a2bde0ea33b30579d84c0ce4</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>根据kubeadm日志输出提示操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@test01 ~]# mkdir -p $HOME/.kube</span><br><span class="line">[root@test01 ~]# sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">[root@test01 ~]# sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line">[root@test01 ~]# kubectl get po --all-namespaces</span><br><span class="line">NAMESPACE     NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-system   coredns-58cc8c89f4-jrfqj         0/1     Pending   0          12m</span><br><span class="line">kube-system   coredns-58cc8c89f4-qh5bg         0/1     Pending   0          12m</span><br><span class="line">kube-system   etcd-test01                      1/1     Running   0          11m</span><br><span class="line">kube-system   kube-apiserver-test01            1/1     Running   0          11m</span><br><span class="line">kube-system   kube-controller-manager-test01   1/1     Running   0          11m</span><br><span class="line">kube-system   kube-proxy-m6hp2                 1/1     Running   0          12m</span><br><span class="line">kube-system   kube-scheduler-test01            1/1     Running   0          11m</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>继续安装网络插件<br>kube-flannel.yml下载地址如下<br><a href="https://raw.githubusercontent.com/coreos/flannel/a70459be0084506e4ec919aa1c114638878db11b/Documentation/kube-flannel.yml">https://raw.githubusercontent.com/coreos/flannel/a70459be0084506e4ec919aa1c114638878db11b/Documentation/kube-flannel.yml</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@test01 ~]# kubectl apply -f kube-flannel.yml</span><br><span class="line">podsecuritypolicy.policy/psp.flannel.unprivileged created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/flannel created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/flannel created</span><br><span class="line">serviceaccount/flannel created</span><br><span class="line">configmap/kube-flannel-cfg created</span><br><span class="line">daemonset.apps/kube-flannel-ds-amd64 created</span><br><span class="line">daemonset.apps/kube-flannel-ds-arm64 created</span><br><span class="line">daemonset.apps/kube-flannel-ds-arm created</span><br><span class="line">daemonset.apps/kube-flannel-ds-ppc64le created</span><br><span class="line">daemonset.apps/kube-flannel-ds-s390x created</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="添加worknode节点"><a href="#添加worknode节点" class="headerlink" title="添加worknode节点"></a>添加worknode节点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@test02 yum.repos.d]# kubeadm join 192.168.0.16:6443 --token 7e169l.60ykxxr8md7sb8ak \</span><br><span class="line">&gt;     --discovery-token-ca-cert-hash sha256:c0b04a34ac7bb55fdf5b04a70233c14c15a11341a2bde0ea33b30579d84c0ce4</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">	[WARNING Hostname]: hostname &quot;test02&quot; could not be reached</span><br><span class="line">	[WARNING Hostname]: hostname &quot;test02&quot;: lookup test02 on 10.16.140.4:53: no such host</span><br><span class="line">[preflight] Reading configuration from the cluster...</span><br><span class="line">[preflight] FYI: You can look at this config file with &#x27;kubectl -n kube-system get cm kubeadm-config -oyaml&#x27;</span><br><span class="line">[kubelet-start] Downloading configuration for the kubelet from the &quot;kubelet-config-1.16&quot; ConfigMap in the kube-system namespace</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet-start] Activating the kubelet service</span><br><span class="line">[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run &#x27;kubectl get nodes&#x27; on the control-plane to see this node join the cluster.</span><br><span class="line"></span><br><span class="line">[root@test01 ~]# kubectl get po --all-namespaces -o wide</span><br><span class="line">NAMESPACE     NAME                             READY   STATUS    RESTARTS   AGE     IP             NODE     NOMINATED NODE   READINESS GATES</span><br><span class="line">kube-system   coredns-58cc8c89f4-jrfqj         1/1     Running   0          46m     10.244.0.3     test01   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   coredns-58cc8c89f4-qh5bg         1/1     Running   0          46m     10.244.0.2     test01   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   etcd-test01                      1/1     Running   0          45m     192.168.0.16   test01   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-apiserver-test01            1/1     Running   0          45m     192.168.0.16   test01   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-controller-manager-test01   1/1     Running   0          45m     192.168.0.16   test01   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-flannel-ds-amd64-7cwtb      1/1     Running   0          5m40s   192.168.0.16   test01   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-flannel-ds-amd64-gcw85      1/1     Running   1          3m47s   192.168.0.18   test03   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-flannel-ds-amd64-sqj75      1/1     Running   0          3m50s   192.168.0.17   test02   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-proxy-fr7wk                 1/1     Running   0          3m47s   192.168.0.18   test03   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-proxy-m6hp2                 1/1     Running   0          46m     192.168.0.16   test01   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-proxy-qpv2g                 1/1     Running   0          3m50s   192.168.0.17   test02   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-scheduler-test01            1/1     Running   0          45m     192.168.0.16   test01   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">[root@test01 ~]# kubectl get no</span><br><span class="line">NAME     STATUS   ROLES    AGE     VERSION</span><br><span class="line">test01   Ready    master   46m     v1.16.4</span><br><span class="line">test02   Ready    &lt;none&gt;   4m1s    v1.16.4</span><br><span class="line">test03   Ready    &lt;none&gt;   3m58s   v1.16.4</span><br></pre></td></tr></table></figure>

<h2 id="测试K8s集群"><a href="#测试K8s集群" class="headerlink" title="测试K8s集群"></a>测试K8s集群</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@test01 ~]# kubectl create deployment nginx --image=nginx</span><br><span class="line">deployment.apps/nginx created</span><br><span class="line">[root@test01 ~]# kubectl expose deployment nginx --port=80 --type=NodePort</span><br><span class="line">service/nginx exposed</span><br><span class="line">[root@test01 ~]# kubectl get pods,svc</span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/nginx-86c57db685-8mmgz   1/1     Running   0          21s</span><br><span class="line"></span><br><span class="line">NAME                 TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">service/kubernetes   ClusterIP   10.1.0.1      &lt;none&gt;        443/TCP        55m</span><br><span class="line">service/nginx        NodePort    10.1.210.90   &lt;none&gt;        80:30580/TCP   13s</span><br><span class="line"></span><br><span class="line">[root@test01 ~]# curl -I 10.1.210.90</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.17.8</span><br><span class="line">Date: Thu, 13 Feb 2020 15:04:16 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 612</span><br><span class="line">Last-Modified: Tue, 21 Jan 2020 13:36:08 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: &quot;5e26fe48-264&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"></span><br><span class="line">[root@test01 ~]# curl -I 192.168.0.18:30580</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.17.8</span><br><span class="line">Date: Thu, 13 Feb 2020 15:04:25 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 612</span><br><span class="line">Last-Modified: Tue, 21 Jan 2020 13:36:08 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: &quot;5e26fe48-264&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure>

<h2 id="部署Dashboard"><a href="#部署Dashboard" class="headerlink" title="部署Dashboard"></a>部署Dashboard</h2><blockquote>
<p>安装参考官方<a href="https://github.com/kubernetes/dashboard">https://github.com/kubernetes/dashboard</a></p>
</blockquote>
<blockquote>
<p>1、预先在$HOME&#x2F;certs目录下放置apiserver证书</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@test01 ~]# ll</span><br><span class="line">-rw-------. 1 root root  1348 8月  13 2018 anaconda-ks.cfg</span><br><span class="line">drwxr-xr-x  2 root root  4096 2月  23 04:36 certs</span><br><span class="line">-rw-r--r--  1 root root  7682 2月  23 05:01 dashboard-recommended.yaml</span><br><span class="line">-rw-r--r--  1 root root 14428 2月  13 22:46 kube-flannel.yml</span><br><span class="line">[root@test01 ~]# kubectl create secret generic kubernetes-dashboard-certs --from-file=$HOME/certs -n kubernetes-dashboard</span><br><span class="line">secret/kubernetes-dashboard-certs created</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2、部署dashboard-recommended.yaml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@test01 ~]# kubectl apply -f dashboard-recommended.yaml</span><br><span class="line">namespace/kubernetes-dashboard created</span><br><span class="line">serviceaccount/kubernetes-dashboard created</span><br><span class="line">service/kubernetes-dashboard created</span><br><span class="line">secret/kubernetes-dashboard-certs created</span><br><span class="line">secret/kubernetes-dashboard-csrf created</span><br><span class="line">secret/kubernetes-dashboard-key-holder created</span><br><span class="line">configmap/kubernetes-dashboard-settings created</span><br><span class="line">role.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">deployment.apps/kubernetes-dashboard created</span><br><span class="line">service/dashboard-metrics-scraper created</span><br><span class="line">deployment.apps/dashboard-metrics-scraper created</span><br><span class="line"></span><br><span class="line">[root@test01 ~]# kubectl get po -n kubernetes-dashboard</span><br><span class="line">NAME                                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">dashboard-metrics-scraper-7b8b58dc8b-x5p9p   1/1     Running   0          18m</span><br><span class="line">kubernetes-dashboard-557f4b4587-zjglq        1/1     Running   0          18m</span><br><span class="line">[root@test01 ~]#</span><br><span class="line">[root@test01 ~]# kubectl get svc -n kubernetes-dashboard</span><br><span class="line">NAME                        TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">dashboard-metrics-scraper   ClusterIP   10.1.80.221    &lt;none&gt;        8000/TCP        21m</span><br><span class="line">kubernetes-dashboard        NodePort    10.1.241.233   &lt;none&gt;        443:30001/TCP   21m</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>3、重新创建serviceaccount并绑定默认cluster-admin管理员集群角色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@test01 ~]# kubectl delete clusterrolebinding kubernetes-dashboard</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io &quot;kubernetes-dashboard&quot; deleted</span><br><span class="line">[root@test01 ~]# kubectl create clusterrolebinding kubernetes-dashboard --clusterrole=cluster-admin --serviceaccount=kubernetes-dashboard:kubernetes-dashboard</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>4、获取token，访问30001端口输入token即可成功登录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@test01 ~]# kubectl get secret -n kubernetes-dashboard</span><br><span class="line">NAME                               TYPE                                  DATA   AGE</span><br><span class="line">default-token-vzv7l                kubernetes.io/service-account-token   3      4m26s</span><br><span class="line">kubernetes-dashboard-certs         Opaque                                2      3m24s</span><br><span class="line">kubernetes-dashboard-csrf          Opaque                                1      4m26s</span><br><span class="line">kubernetes-dashboard-key-holder    Opaque                                2      4m26s</span><br><span class="line">kubernetes-dashboard-token-hpff2   kubernetes.io/service-account-token   3      4m26s</span><br><span class="line"></span><br><span class="line">[root@test01 ~]# kubectl describe secret kubernetes-dashboard-token-hpff2 -n kubernetes-dashboard |grep token:</span><br><span class="line">token:      eyJhbGciOiJSUzI1NiIsImtpZCI6InBYV1Utc2Yxc0JvWE5zQkFpTW1lX2hpRmJKY3ZWOWhkSDhWWHFscHBSMTAifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJrdWJlcm5ldGVzLWRhc2hib2FyZC10b2tlbi1ocGZmMiIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjkyOWI3NTczLWU5OGQtNGU1NC04NTBiLWQyZmYyODIxYWM3ZSIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlcm5ldGVzLWRhc2hib2FyZDprdWJlcm5ldGVzLWRhc2hib2FyZCJ9.gK7EsvOnaeCUBcIoDTwsH323ZhQ_tmtYFuC9v8DRlKiX_nMbzBiMzmrvCxGRvXeD-ntlmLBE56R9s2yrUEt-3cx0_QFWYBZGmayVMqY7I-sj8fwSwJOYizq6SE4KZO8Ek3bc7qpV2BxKktWVZl77v7jU7upbtMtNRogFCKEAJWdGztpYoSD9F8s-osvcPJMYhHAYhLs002d84ux-CZUTadTMu9Y-mJ-0M5oulNLXB8m3TueAva-Tav6Hgw-1_ABPtpnOLbPJoaHqIzBXhMAgiKKpF6gs0GCui0-8sKGTFlY9jBNuUZSzIF4K9yKEHeF82ZNj9PxlBVajeej7pbCmOg</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="部署遇到的问题记录（待确认）"><a href="#部署遇到的问题记录（待确认）" class="headerlink" title="部署遇到的问题记录（待确认）"></a>部署遇到的问题记录（待确认）</h1><blockquote>
<p>问题1、kubeadm join时出现warn信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[WARNING Hostname]: hostname &quot;test02&quot; could not be reached</span><br><span class="line">[WARNING Hostname]: hostname &quot;test02&quot;: lookup test02 on 10.16.140.4:53: no such host</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>问题2、kube-proxy没有开启ipvs，默认用了iptables Proxier</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@test01 ~]# kubectl logs kube-proxy-fr7wk  -n kube-system</span><br><span class="line">W0213 14:48:50.804540       1 proxier.go:592] Failed to load kernel module ip_vs with modprobe. You can ignore this message when kube-proxy is running inside container without mounting /lib/modules</span><br><span class="line">W0213 14:48:50.805641       1 proxier.go:592] Failed to load kernel module ip_vs_rr with modprobe. You can ignore this message when kube-proxy is running inside container without mounting /lib/modules</span><br><span class="line">W0213 14:48:50.806607       1 proxier.go:592] Failed to load kernel module ip_vs_wrr with modprobe. You can ignore this message when kube-proxy is running inside container without mounting /lib/modules</span><br><span class="line">W0213 14:48:50.807514       1 proxier.go:592] Failed to load kernel module ip_vs_sh with modprobe. You can ignore this message when kube-proxy is running inside container without mounting /lib/modules</span><br><span class="line">W0213 14:48:50.811786       1 server_others.go:330] Flag proxy-mode=&quot;&quot; unknown, assuming iptables proxy</span><br><span class="line">I0213 14:48:50.819927       1 node.go:135] Successfully retrieved node IP: 192.168.0.18</span><br><span class="line">I0213 14:48:50.819966       1 server_others.go:150] Using iptables Proxier.</span><br><span class="line">I0213 14:48:50.820484       1 server.go:529] Version: v1.16.4</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>问题3、etcd有异常日志出现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2020-02-13 14:48:04.732974 W | wal: sync duration of 1.126809415s, expected less than 1s</span><br><span class="line">2020-02-13 14:48:04.733537 W | etcdserver: read-only range request &quot;key:\&quot;/registry/services/endpoints/kube-system/kube-scheduler\&quot; &quot; with result &quot;range_response_count:1 size:429&quot; took too long (760.032104ms) to execute</span><br><span class="line">2020-02-13 14:48:04.733800 W | etcdserver: read-only range request &quot;key:\&quot;/registry/minions/test02\&quot; &quot; with result &quot;range_response_count:0 size:5&quot; took too long (975.286916ms) to execute</span><br><span class="line">2020-02-13 14:48:04.733918 W | etcdserver: read-only range request &quot;key:\&quot;/registry/jobs/\&quot; range_end:\&quot;/registry/jobs0\&quot; limit:500 &quot; with result &quot;range_response_count:0 size:5&quot; took too long (332.81178ms) to execute</span><br><span class="line">2020-02-13 14:48:04.734030 W | etcdserver: read-only range request &quot;key:\&quot;/registry/pods\&quot; range_end:\&quot;/registry/podt\&quot; count_only:true &quot; with result &quot;range_response_count:0 size:7&quot; took too long (377.827782ms) to execute</span><br><span class="line">2020-02-13 14:48:04.734145 W | etcdserver: read-only range request &quot;key:\&quot;/registry/services/endpoints/kube-system/kube-controller-manager\&quot; &quot; with result &quot;range_response_count:1 size:447&quot; took too long (431.157766ms) to execute</span><br><span class="line">2020-02-13 14:48:04.734246 W | etcdserver: read-only range request &quot;key:\&quot;/registry/minions/test03\&quot; &quot; with result &quot;range_response_count:0 size:5&quot; took too long (1.05179271s) to execute</span><br><span class="line">2020-02-13 14:48:04.734349 W | etcdserver: read-only range request &quot;key:\&quot;/registry/pods/\&quot; range_end:\&quot;/registry/pods0\&quot; limit:500 &quot; with result &quot;range_response_count:8 size:18170&quot; took too long (292.020624ms) to execute</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>问题4、api-server报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I0213 16:31:39.167022       1 log.go:172] http: TLS handshake error from 192.168.0.10:59610: remote error: tls: bad certificate</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>问题5、kube-scheduler报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User &quot;system:kube-scheduler&quot; cannot list resource &quot;replicationcontrollers&quot; in API group &quot;&quot; at the cluster scope</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>问题6、kubectl get cs问题（上游问题，影响版本从1.16之后。）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@test01 ~]# kubectl get cs</span><br><span class="line">NAME                 AGE</span><br><span class="line">scheduler            &lt;unknown&gt;</span><br><span class="line">controller-manager   &lt;unknown&gt;</span><br><span class="line">etcd-0               &lt;unknown&gt;</span><br><span class="line">#workround方案：</span><br><span class="line">[root@test01 ~]# kubectl get cs -o=go-template=&#x27;&#123;&#123;printf &quot;|NAME|STATUS|MESSAGE|\n&quot;&#125;&#125;&#123;&#123;range .items&#125;&#125;&#123;&#123;$name := .metadata.name&#125;&#125;&#123;&#123;range .conditions&#125;&#125;&#123;&#123;printf &quot;|%s|%s|%s|\n&quot; $name .status .message&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span><br><span class="line">|NAME|STATUS|MESSAGE|</span><br><span class="line">|controller-manager|True|ok|</span><br><span class="line">|scheduler|True|ok|</span><br><span class="line">|etcd-0|True|&#123;&quot;health&quot;:&quot;true&quot;&#125;|</span><br></pre></td></tr></table></figure>
</blockquote>
<p>参考链接：<br><a href="https://cloud.tencent.com/developer/article/1509412">https://cloud.tencent.com/developer/article/1509412</a><br><a href="https://www.kubernetes.org.cn/6632.html">https://www.kubernetes.org.cn/6632.html</a></p>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>kubeadm</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 基础知识总结</title>
    <url>/2018/07/01/linux-basic/</url>
    <content><![CDATA[<h1 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h1><h2 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h2><p>“一切皆是文件”是 Unix&#x2F;Linux 的基本哲学之一，它是指 Linux 系统中的所有的一切都可以通过文件的方式访问、管理，即使不是文件，也以文件的形式来管理。例如硬件设备、进程、套接字等都抽象成伪文件，使用统一的用户接口，虽然文件类型各不相同，但是对其提供的却是同一套操作。</p>
<p>在 Linux 中共有 7 种类型的文件，使用了不同的字符来加以区分，其中伪文件并不占用磁盘空间：</p>
<table>
<thead>
<tr>
<th>文件类型标识</th>
<th>文件类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>-</code></td>
<td>普通文件</td>
</tr>
<tr>
<td><code>d</code></td>
<td>目录文件</td>
</tr>
<tr>
<td><code>l</code></td>
<td>符号链接</td>
</tr>
<tr>
<td><code>c</code>（伪文件）</td>
<td>字符设备（character device）</td>
</tr>
<tr>
<td><code>b</code>（伪文件）</td>
<td>块设备（block device）</td>
</tr>
<tr>
<td><code>s</code>（伪文件）</td>
<td>套接字文件（socket）</td>
</tr>
<tr>
<td><code>p</code>（伪文件）</td>
<td>命名管道文件（pipe）</td>
</tr>
</tbody></table>
<p><strong>硬件设备命名</strong></p>
<p>系统内核中的udev设备管理器会自动把硬件名称规范起来，目的是让用户通过设备文件的名字可以猜出设备大致的属性以及分区信息等；这对于陌生的设备来说特别方便。</p>
<table>
<thead>
<tr>
<th>硬件设备</th>
<th>文件名称</th>
</tr>
</thead>
<tbody><tr>
<td>SCSI&#x2F;SATA&#x2F;U盘</td>
<td>&#x2F;dev&#x2F;sd[a-z]</td>
</tr>
<tr>
<td>virtio设备</td>
<td>&#x2F;dev&#x2F;vd[a-z]（用于虚拟机内）</td>
</tr>
<tr>
<td>软驱</td>
<td>&#x2F;dev&#x2F;fd[0-7]</td>
</tr>
<tr>
<td>打印机</td>
<td>&#x2F;dev&#x2F;lp[0-15]</td>
</tr>
<tr>
<td>光驱CDROM</td>
<td>&#x2F;dev&#x2F;sr[0-1] （通用，CentOS 较常见）&#x2F;dev&#x2F;cdrom （当前 CDROM）</td>
</tr>
<tr>
<td>鼠标</td>
<td>&#x2F;dev&#x2F;mouse</td>
</tr>
<tr>
<td>磁带机</td>
<td>&#x2F;dev&#x2F;st0或&#x2F;dev&#x2F;ht0</td>
</tr>
</tbody></table>
<h2 id="目录树结构"><a href="#目录树结构" class="headerlink" title="目录树结构"></a>目录树结构</h2><p>在Windows操作系统中，想要找到一个文件，要依次进入该文件所在的磁盘分区（也叫盘符），然后再进入该分区下的具体目录，最终找到这个文件。但是在Linux系统中并不存在C、D、E、F等盘符，<strong>Linux系统中的一切文件都是从“根”目录（&#x2F;）开始的，并按照文件系统层次标准(FHS)采用倒树状结构来存放文件，以及定义了常见目录的用途。</strong></p>
<img src="/2018/07/01/linux-basic/linux-file-system-directory.png" class="" title="img">

<p>Linux系统中常见的目录名称以及相应内容</p>
<table>
<thead>
<tr>
<th>目录名称</th>
<th>应放置文件的内容</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;boot</td>
<td>开机所需文件—内核、开机菜单以及所需配置文件等</td>
</tr>
<tr>
<td>&#x2F;dev</td>
<td>以文件形式存放任何设备与接口</td>
</tr>
<tr>
<td>&#x2F;etc</td>
<td>配置文件</td>
</tr>
<tr>
<td>&#x2F;home</td>
<td>用户主目录</td>
</tr>
<tr>
<td>&#x2F;bin</td>
<td>存放单用户模式下还可以操作的[命令]</td>
</tr>
<tr>
<td>&#x2F;lib</td>
<td>开机时用到的函数库，以及&#x2F;bin与&#x2F;sbin下面的命令要调用的函数</td>
</tr>
<tr>
<td>&#x2F;sbin</td>
<td>开机过程中需要的命令</td>
</tr>
<tr>
<td>&#x2F;media</td>
<td>用于挂载设备文件的目录</td>
</tr>
<tr>
<td>&#x2F;opt</td>
<td>放置第三方的软件</td>
</tr>
<tr>
<td>&#x2F;root</td>
<td>系统管理员的家目录</td>
</tr>
<tr>
<td>&#x2F;srv</td>
<td>一些网络服务的数据文件目录</td>
</tr>
<tr>
<td>&#x2F;tmp</td>
<td>任何人均可使用的“共享”临时目录</td>
</tr>
<tr>
<td>&#x2F;proc</td>
<td>虚拟文件系统，例如系统内核、进程、外部设备及网络状态等</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;local</td>
<td>用户自行安装的软件</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;sbin</td>
<td>Linux系统开机时不会使用到的软件&#x2F;命令&#x2F;[脚本]</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share</td>
<td>帮助与说明文件，也可放置共享文件</td>
</tr>
<tr>
<td>&#x2F;var</td>
<td>主要存放经常变化的文件，如日志</td>
</tr>
<tr>
<td>&#x2F;lost+found</td>
<td>当文件系统发生错误时，将一些丢失的文件片段存放在这里</td>
</tr>
</tbody></table>
<h2 id="inode介绍"><a href="#inode介绍" class="headerlink" title="inode介绍"></a>inode介绍</h2><ul>
<li>inode （索引节点）是 Linux&#x2F;Unix 文件系统的基础。</li>
<li><code>stat</code> 命令可以查看文件的 inode 信息，包括文件元信息（例如权限、大小、修改时间以及数据块位置）</li>
<li>inode 的访问速度非常快，Unix&#x2F;Linux系统通过 inode 号码定位到文件的元数据信息，进而读取文件的块数据（4k、1M），无需遍历整个文件系统</li>
<li>inode 的数量是有限的，每个文件系统只能包含固定数量的 inode。这意味着当文件系统中的 inode 用完时，无法再创建新的文件或目录，即使磁盘上还有可用空间。因此，在创建文件系统时，需要根据文件和目录的预期数量来合理分配 inode 的数量。</li>
</ul>
<h2 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h2><p><strong>硬链接</strong></p>
<p>在 Linux&#x2F;类 Unix 文件系统中，每个文件和目录都有一个唯一的索引节点（inode）号，用来标识该文件或目录。但是，Unix&#x2F;Linux系统允许，多个文件名指向同一个inode号码。</p>
<ul>
<li><code>ln</code> 命令用于创建硬链接</li>
<li>硬链接和源文件的 inode 节点号相同，两者对文件系统来说是完全平等的（可以看作是互为硬链接，源头是同一份文件）</li>
<li>只有删除了源文件和所有对应的硬链接文件，该文件才会被真正删除。</li>
<li>硬链接具有一些限制，不能对目录以及不存在的文件创建硬链接，并且，硬链接也不能跨越文件系统。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]# ll -i /etc/crontab</span><br><span class="line">268535884 -rw-r--r-- 1 root root 451 Mar 14  2020 /etc/crontab</span><br><span class="line"></span><br><span class="line">[root@master01 ~]# <span class="built_in">ln</span> /etc/crontab .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立硬链接，链接数加1</span></span><br><span class="line">[root@master01 ~]# ll -i /etc/crontab crontab</span><br><span class="line">268535884 -rw-r--r-- 2 root root 451 Mar 14  2020 crontab</span><br><span class="line">268535884 -rw-r--r-- 2 root root 451 Mar 14  2020 /etc/crontab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除硬链接，链接数减1</span></span><br><span class="line">[root@master01 ~]# <span class="built_in">rm</span> -rf crontab</span><br><span class="line">[root@master01 ~]# ll -i /etc/crontab</span><br><span class="line">268535884 -rw-r--r-- 1 root root 451 Mar 14  2020 /etc/crontab</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>软链接</strong></p>
<ul>
<li><code>ln -s</code> 命令用于创建软链接</li>
<li>软链接和源文件的 inode 节点号不同，而是指向一个文件路径</li>
<li>软连接类似于 Windows 系统中的快捷方式。即源文件删除后，软链接依然存在，但是指向的是一个无效的文件路径</li>
<li>不同于硬链接，可以对目录或者不存在的文件创建软链接，并且，软链接可以跨越文件系统。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]# <span class="built_in">ln</span> -s /etc/crontab crontab_test</span><br><span class="line"></span><br><span class="line">[root@master01 ~]# ll -i /etc/crontab crontab_test</span><br><span class="line">344677386 lrwxrwxrwx 1 root root  12 Jan 20 18:41 crontab_test -&gt; /etc/crontab</span><br><span class="line">268535884 -rw-r--r-- 1 root root 451 Mar 14  2020 /etc/crontab</span><br></pre></td></tr></table></figure>

<p>在Linux系统上&#x2F;bin&#x2F;sh通常就是指向&#x2F;bin&#x2F;bash的软链接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]# ll -i /bin/sh</span><br><span class="line">872423134 lrwxrwxrwx 1 root root 4 Feb 20  2024 /bin/sh -&gt; bash</span><br><span class="line"></span><br><span class="line">[root@master01 ~]# ll -i /bin/bash</span><br><span class="line">872423123 -rwxr-xr-x 1 root root 1166952 Feb 20  2024 /bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="常用文件系统"><a href="#常用文件系统" class="headerlink" title="常用文件系统"></a>常用文件系统</h2><h3 id="XFS系统"><a href="#XFS系统" class="headerlink" title="XFS系统"></a>XFS系统</h3><p>XFS 是一种高性能的文件系统，相比 ext4，它在某些方面具有显著优势。如下：</p>
<ul>
<li><strong>大文件处理</strong>：XFS 在处理大文件时性能优异，适合需要频繁读写大文件的场景（如视频编辑、数据库）。</li>
<li><strong>高并发</strong>：XFS 通过延迟分配（Delayed Allocation）和分布式 B+ 树索引，优化了高并发写入性能，特别是在多线程场景下，能够更好地利用多核 CPU，适合高并发工作负载。</li>
<li><strong>动态 inode 分配</strong>：XFS 可以动态分配 inode，而 ext4 需要在创建文件系统时预先分配 inode，可能导致 inode 不足和格式化速度慢的问题。</li>
<li><strong>高效的日志机制</strong>：XFS 的日志机制更高效，能够快速恢复文件系统一致性，尤其在系统崩溃后。</li>
</ul>
<h1 id="Linux-硬盘与文件系统管理"><a href="#Linux-硬盘与文件系统管理" class="headerlink" title="Linux 硬盘与文件系统管理"></a>Linux 硬盘与文件系统管理</h1><h2 id="硬盘类型"><a href="#硬盘类型" class="headerlink" title="硬盘类型"></a><strong>硬盘类型</strong></h2><img src="/2018/07/01/linux-basic/disk.png" class="" title="disk">

<p><strong>机械硬盘</strong>（HDD）的组成主要有盘片、机械手臂、磁头与主轴马达所组成，而数据的写入其实是在盘片上面。盘片上面又可细分出扇区（Sector）与磁道（Track）两种单位，其中扇区的容量设计有两种大小，分别是 512Bytes 与 4KBytes。</p>
<p><strong>固态硬盘</strong>（SSD）是基于半导体闪存（NAND Flash）作为存储介质的硬盘，相比传统的机械硬盘，它去掉了机械固件，引入了主控芯片来代替机械操作，这意味着它的性能、功耗及可靠性会比HDD高出一大截。固态硬盘虽然没有物理扇区，但逻辑上仍保留扇区的概念以兼容操作系统和文件系统。</p>
<p>关于硬盘的总结如下：</p>
<ul>
<li>扇区（Sector）为最小的物理储存单位，且依据磁盘设计的不同，目前主要有 512Bytes与 4K 两种格式；</li>
<li>柱面（cylinder）是由多个盘片上处于同一磁道位置（即同一半径）的磁道组成的集合；</li>
</ul>
<h2 id="硬盘分区和挂载"><a href="#硬盘分区和挂载" class="headerlink" title="硬盘分区和挂载"></a>硬盘分区和挂载</h2><p><strong>分区工具</strong><br>常用的分区工具有 <code>fdisk</code>、<code>parted</code>、Windows 下的磁盘管理工具等。使用这些工具可以在硬盘上建立一个分区表，用于记录每个分区的起始位置、结束位置、大小及其它属性。</p>
<p><strong>分区表类型</strong></p>
<p><strong>MBR（Master Boot Record）</strong>：传统的分区表格式，最多支持4个主分区（或3个主分区加一个扩展分区，扩展分区内可创建多个逻辑分区）。</p>
<p>MBR 分区表中，第一个扇区最重要，里面有主开机记录（Master boot record,MBR）及分区表（partition table），其中 MBR 占有 446 Bytes，而 partition table 则占有 64 Bytes。</p>
<img src="/2018/07/01/linux-basic/1737022182076-13.png"  alt="img" style="zoom:50%;" />

<p><strong>GPT（GUID Partition Table）</strong>：现代硬盘常用的分区表格式，支持更多分区，且对于大容量硬盘有更好的支持和数据冗余能力。</p>
<p><strong>分区过程</strong><br>分区工具会让你选择起始扇区和结束扇区，从而决定每个分区的大小。现在的分区都是基于逻辑扇区（LBA）进行划分的。</p>
<ul>
<li><strong>指定大小和位置</strong>：用户可以根据需要指定各个分区的大小和位置，确保不同的分区满足不同应用场景的需求。</li>
<li><strong>确定分区类型</strong>：通常会根据用途为分区分配不同的标记或文件系统类型（如Linux下的 ext4、swap 分区，Windows下的 NTFS 等）。</li>
<li><strong>写入分区表</strong>：完成分区配置后，工具会将信息写入硬盘的分区表中。以后系统启动时，就会根据这个分区表来识别和管理各个分区。</li>
</ul>
<p><strong>方法一：分区 → 格式化 → 挂载</strong></p>
<p>使用步骤：</p>
<ol>
<li>输入 <code>n</code> 创建新分区。</li>
<li>输入分区类型（如 <code>primary</code> 或 <code>logical</code>）。</li>
<li>设置起始和结束扇区（通常直接按回车使用默认值）。</li>
<li>输入 <code>w</code> 保存分区表并退出。</li>
<li>格式化分区</li>
<li>挂载分区</li>
<li>开机自动挂载（可选）</li>
</ol>
<img src="/2018/07/01/linux-basic/output.png" class="" title="output">

<img src="/2018/07/01/linux-basic/output-1737083379812-9.png" class="" title="output">

<p><strong>方法二：直接格式化→ 挂载</strong></p>
<p>这种方法适合特定用途，例如非系统盘的大容量存储。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mkfs.ext4 /dev/sdb</span><br><span class="line"><span class="built_in">sudo</span> mount /dev/sdb /mnt/data</span><br></pre></td></tr></table></figure>

<p><strong>方法三：使用 LVM（逻辑卷管理器）</strong></p>
<p>如果需要灵活管理硬盘容量，可以使用 LVM：初始化 → 创建卷组 → 创建逻辑卷 → 格式化 → 挂载</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化硬盘</span></span><br><span class="line"><span class="built_in">sudo</span> pvcreate /dev/sdb</span><br><span class="line"><span class="comment"># 创建卷组</span></span><br><span class="line"><span class="built_in">sudo</span> vgcreate my_vg /dev/sdb</span><br><span class="line"><span class="comment"># 创建逻辑卷</span></span><br><span class="line"><span class="built_in">sudo</span> lvcreate -L 50G -n my_lv my_vg</span><br><span class="line"><span class="comment">#格式化卷</span></span><br><span class="line"><span class="built_in">sudo</span> mkfs.ext4 /dev/my_vg/my_lv</span><br><span class="line"><span class="comment">#挂载卷</span></span><br><span class="line"><span class="built_in">sudo</span> mount /dev/my_vg/my_lv /mnt/data</span><br></pre></td></tr></table></figure>

<p><strong>方法四：作为裸设备使用</strong></p>
<p>某些特殊用途（如数据库或存储系统）可能直接使用裸设备，无需分区和格式化。例如数据库（如 MySQL）可以直接将 <code>/dev/sdb</code> 作为数据存储路径。</p>
<h2 id="硬盘阵列技术"><a href="#硬盘阵列技术" class="headerlink" title="硬盘阵列技术"></a>硬盘阵列技术</h2><p>RAID技术的设计初衷是减少因为采购硬盘设备带来的费用支出，但是与数据本身的价值相比较，<strong>现代企业更看重的则是RAID技术所具备的冗余备份机制以及带来的硬盘吞吐量的提升</strong>。也就是说，RAID不仅降低了硬盘设备损坏后丢失数据的几率，还提升了硬盘设备的读写速度，所以它在绝大多数运营商或大中型企业中得以广泛部署和应用。</p>
<h3 id="RAID-特性"><a href="#RAID-特性" class="headerlink" title="RAID 特性"></a>RAID 特性</h3><ul>
<li><strong>协同工作</strong>：多块硬盘通过一定的 RAID 级别协同工作。</li>
<li><strong>性能提升</strong>：通过并行读写提高数据吞吐量（如 RAID 0、RAID 10）。</li>
<li><strong>可靠性增强</strong>：通过数据冗余提高数据安全性（如 RAID 1、RAID 5）。</li>
<li><strong>容量组合</strong>：多块硬盘的容量可以组合成一个逻辑卷。</li>
<li><strong>应用场景</strong>：适用于服务器、企业级存储、大型数据库系统等。</li>
</ul>
<h3 id="常见的-RAID-级别"><a href="#常见的-RAID-级别" class="headerlink" title="常见的 RAID 级别"></a>常见的 RAID 级别</h3><table>
<thead>
<tr>
<th><strong>RAID 级别</strong></th>
<th><strong>特点</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RAID 0</td>
<td>数据交错存放，性能提升，但无数据冗余，一块硬盘损坏即丢失全部数据</td>
</tr>
<tr>
<td>RAID 1</td>
<td>两块硬盘存储相同数据，可靠性高但容量利用率低，若使用软件RAID，可能写入性能会变差</td>
</tr>
<tr>
<td>RAID 5</td>
<td>分布式校验数据，性能和可靠性均衡，需要至少 3 块硬盘；当一块磁盘损毁时，可以通过同位检查码重建数据</td>
</tr>
<tr>
<td>RAID 10</td>
<td>RAID 1+0，性能和可靠性均高，需要至少 4 块硬盘</td>
</tr>
</tbody></table>
<h3 id="软件-RAID"><a href="#软件-RAID" class="headerlink" title="软件 RAID"></a><strong>软件 RAID</strong></h3><p>由于磁盘阵列有很多优秀的功能，然而硬件磁盘阵列卡偏偏又贵的很～因此就有发展出利用软件来仿真磁盘阵列的功能，这就是所谓的软件磁盘阵列（software RAID）。软件磁盘阵列主要是通过软件来仿真阵列的任务，因此会损耗较多的系统资源，比如说 CPU 的运算与I&#x2F;O 总线的资源等。</p>
<blockquote>
<p>硬件磁盘阵列（hardware RAID）是通过磁盘阵列卡来达成阵列的目的。磁盘阵列卡上面有一块专门的芯片在处理 RAID 的任务，因此在性能方面会比较好。</p>
</blockquote>
<p>软件实现 RAID，通过 Linux 的 <code>mdadm</code> 工具配置软件 RAID。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mdadm --create /dev/md0 --level=5 --raid-devices=3 /dev/sd[b-d]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell编程</title>
    <url>/2018/07/09/linux-shell/</url>
    <content><![CDATA[<h1 id="Linux-Shell"><a href="#Linux-Shell" class="headerlink" title="Linux Shell"></a>Linux Shell</h1><p>Shell是这样的一个命令行工具（也称为终端或壳），充当的是人与内核之间的翻译官，用户把一些命令“告诉”终端，它就会调用相应的程序服务去完成某些工作。</p>
<h2 id="Bash-shell-功能"><a href="#Bash-shell-功能" class="headerlink" title="Bash shell 功能"></a>Bash shell 功能</h2><p>主流Linux系统选择Bash（Bourne-Again SHell）作为默认的Shell主要有以下4项优势</p>
<p><strong>1、命令记忆功能</strong></p>
<ul>
<li>通过上下方向键来调取过往执行过的Linux命令；</li>
<li>~&#x2F;.bash_history 记录的是前一次登陆以前所执行过的指令，而至于这一次登陆所执行的指令都被暂存在内存中，当用户成功登出系统后，该指令记忆才会记录到 .bash_history 当中</li>
</ul>
<p><strong>2、Tab键自动补全命令或文件</strong></p>
<p><strong>3、命令别名设置功能（alias）</strong></p>
<p><strong>4：程序化脚本（shell scripts）</strong></p>
<img src="/2018/07/09/linux-shell/output-1737428425946-1.png"  alt="output" style="zoom: 25%;" />

<h2 id="Shell-变量"><a href="#Shell-变量" class="headerlink" title="Shell 变量"></a>Shell 变量</h2><p><strong>变量的设置规则：</strong></p>
<ol>
<li>变量名由字母、数字、下划线组成，不能以数字开头。变量名一般习惯用大写</li>
<li>等号两侧不能有空格</li>
<li>变量值若有空白字符，可使用双引号或单引号将变量内容结合起来<ul>
<li>双引号内的特殊字符如 $ 等，可以保有原本的特性</li>
<li>单引号内的特殊字符则仅为一般字符（纯文本）</li>
</ul>
</li>
<li>反斜杠\ 可以将后面的特殊符号（如 [Enter], $, , 空白字符, ‘等）变成一般字符串</li>
<li>反引号&#96;&#96; 或$()可以将其中的命令执行后返回结果</li>
<li>若该变量需要在其他子程序执行，则需要以 export 来使变量变成环境变量： <code>export PATH</code></li>
</ol>
<p><strong>变量基本操作：</strong></p>
<ol>
<li>查看所有环境变量：<code>env</code></li>
<li>查看单个变量：<code>echo $PATH</code>、<code>echo $&#123;HOME&#125;</code></li>
<li>定义变量：<code>变量名=变量值</code></li>
<li>删除变量：<code>unset 变量名</code> </li>
<li>特殊符号变量：<ul>
<li>$$：当前进程的 PID 进程号</li>
<li>$?：上个命令执行的回传值，0为执行成功，非0执行失败</li>
<li>$0：脚本文件名称</li>
<li>$#：脚本的参数个数</li>
<li>$@：代表 「<code>&quot;&amp;1&quot; &quot;&amp;2&quot; &quot;&amp;3&quot; &quot;&amp;4&quot;</code>」 的意思，每个变量是独立的（用双引号括起来）</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例1：使用反斜杠（\）进行转义</span></span><br><span class="line">[root@linuxprobe ~]# PRICE=5</span><br><span class="line">[root@linuxprobe ~]# <span class="built_in">echo</span> <span class="string">&quot;Price is \$<span class="variable">$PRICE</span>&quot;</span></span><br><span class="line">Price is <span class="variable">$5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2:将一个命令的执行结果赋值给变量（重点）</span></span><br><span class="line">[root@node-1 ~]# A=`<span class="built_in">date</span>`</span><br><span class="line">[root@node-1 ~]# <span class="built_in">echo</span> <span class="variable">$A</span></span><br><span class="line">2021年 12月 14日 星期二 01:22:02 CST</span><br><span class="line"></span><br><span class="line">[root@node-1 ~]# A=$(<span class="built_in">date</span>)</span><br><span class="line">[root@node-1 ~]# <span class="built_in">echo</span> <span class="variable">$A</span></span><br><span class="line">2021年 12月 14日 星期二 01:25:22 CST</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例3:单引号和双引号的使用区别</span></span><br><span class="line">[root@node-1 ~]# NAME=<span class="string">&#x27;liao xiaobo&#x27;</span></span><br><span class="line">[root@node-1 ~]# NAME=<span class="string">&quot;My name is <span class="variable">$NAME</span>&quot;</span>	<span class="comment"># 双引号会保留特殊符号的含义</span></span><br><span class="line">[root@node-1 ~]# <span class="built_in">echo</span> <span class="variable">$NAME</span></span><br><span class="line">My name is liao xiaobo</span><br><span class="line"></span><br><span class="line">[root@node-1 ~]# NAME2=<span class="string">&#x27;My name is $NAME&#x27;</span>	<span class="comment"># 单引号之间的内容原封不动的指定给了变量；</span></span><br><span class="line">[root@node-1 ~]# <span class="built_in">echo</span> <span class="variable">$NAME2</span></span><br><span class="line">My name is <span class="variable">$NAME</span></span><br></pre></td></tr></table></figure>

<h2 id="Bash-的环境配置文件"><a href="#Bash-的环境配置文件" class="headerlink" title="Bash 的环境配置文件"></a>Bash 的环境配置文件</h2><p>bash 配置文件的读入方式是通过 source 指令来读取的。</p>
<p>整个 login shell 的读取流程如下：</p>
<img src="/2018/07/09/linux-shell/image-20191201181925883.3d391ba7.png" class="" title="image-20191201181925883">

<p> <code>/etc/profile</code>：这是系统整体的设置，一般不需要修改这个文件；</p>
<p><code>~/.bash_profile</code> 或 <code>~/.bash_login</code>：属于登陆用户的个人设置</p>
<h2 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h2><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。</p>
<p>在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，输出重定向分为标准输出重定向和错误输出重定向两种不同的技术，以及清空写入与追加写入两种模式。</p>
<p>输入重定向中用到的符号及其作用</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>命令 &lt; 文件</td>
<td>将文件作为命令的标准输入</td>
</tr>
<tr>
<td>命令 &lt;&lt; 分界符</td>
<td>从标准输入中读入，直到遇见分界符才停止</td>
</tr>
<tr>
<td>命令 &lt; 文件1 &gt; 文件2</td>
<td>将文件1作为命令的标准输入并将标准输出到文件2</td>
</tr>
</tbody></table>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 远程执行本地shell脚本</span></span><br><span class="line">ssh master02 <span class="string">&#x27;bash -s&#x27;</span>&lt; /opt/kill.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于cat admin-openrc.sh | wc -l的管道符命令组合</span></span><br><span class="line">[root@master01 ~]# <span class="built_in">wc</span> -l &lt; admin-openrc.sh</span><br><span class="line">11</span><br></pre></td></tr></table></figure>

<p>输出重定向中用到的符号及其作用</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>命令 &gt; 文件</td>
<td>将标准输出重定向到一个文件中（清空）</td>
</tr>
<tr>
<td>命令 2&gt; 文件</td>
<td>将错误输出重定向到一个文件中（清空）</td>
</tr>
<tr>
<td>命令 &gt;&gt; 文件</td>
<td>将标准输出重定向到一个文件中（追加）</td>
</tr>
<tr>
<td>命令 2&gt;&gt; 文件</td>
<td>将错误输出重定向到一个文件中（追加）</td>
</tr>
<tr>
<td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td>
<td>将标准输出与错误输出共同写入到文件中（追加）</td>
</tr>
</tbody></table>
<h2 id="常用判断式"><a href="#常用判断式" class="headerlink" title="常用判断式"></a>常用判断式</h2><h3 id="文件判断（类型、权限）"><a href="#文件判断（类型、权限）" class="headerlink" title="文件判断（类型、权限）"></a>文件判断（类型、权限）</h3><table>
<thead>
<tr>
<th align="center">测试的标志</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-e</td>
<td align="left">文件是否存在；<strong>常用</strong></td>
</tr>
<tr>
<td align="center">-f</td>
<td align="left">该文件是否存在且为文件（file）？<strong>常用</strong></td>
</tr>
<tr>
<td align="center">-d</td>
<td align="left">该文件是否存在且为目录（directory）？<strong>常用</strong></td>
</tr>
<tr>
<td align="center">-b</td>
<td align="left">该文件是否存在且为一个 block device ？</td>
</tr>
<tr>
<td align="center">-r</td>
<td align="left">该文件是否存在且具有可读权限？</td>
</tr>
<tr>
<td align="center">-w</td>
<td align="left">该文件是否存在且具有可写权限？</td>
</tr>
<tr>
<td align="center">-x</td>
<td align="left">该文件是否存在且具有可执行权限？</td>
</tr>
<tr>
<td align="center">-ef</td>
<td align="left">判断 file1 与 file2 是否是同一文件，可用在判断 hard link 的判定上。主要意义在判定两个文件是否均指向同一个 inode</td>
</tr>
</tbody></table>
<h3 id="整数比较"><a href="#整数比较" class="headerlink" title="整数比较"></a>整数比较</h3><p>整数比较运算符仅是对数字的操作，不能将数字与字符串、文件等内容一起操作，而且不能想当然地使用日常生活中的等号、大于号、小于号等来判断。</p>
<table>
<thead>
<tr>
<th align="center">测试的标志</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-eq</td>
<td align="left">两数值相等（equal）</td>
</tr>
<tr>
<td align="center">-ne</td>
<td align="left">不相等（not equal）</td>
</tr>
<tr>
<td align="center">-gt</td>
<td align="left">大于（greater than）</td>
</tr>
<tr>
<td align="center">-lt</td>
<td align="left">小于（less than）</td>
</tr>
<tr>
<td align="center">-ge</td>
<td align="left">大于等于（greater than or equal）</td>
</tr>
<tr>
<td align="center">-le</td>
<td align="left">小于等于（less than or equal）</td>
</tr>
</tbody></table>
<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><table>
<thead>
<tr>
<th align="center">测试的标志</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-z string</td>
<td align="left">判定字符串是否为 0？若为空串，则为 true</td>
</tr>
<tr>
<td align="center">-n string</td>
<td align="left">判定字符串是否不为 0？若为空串，则为 false；注意：-n 可省略</td>
</tr>
<tr>
<td align="center">str1 &#x3D;&#x3D; str2</td>
<td align="left">是否相等，相等则为 true</td>
</tr>
<tr>
<td align="center">str1 !&#x3D; str2</td>
<td align="left">是否不相等，相等则为 false</td>
</tr>
</tbody></table>
<h3 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h3><table>
<thead>
<tr>
<th align="center">测试的标志</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-a</td>
<td align="left">（and）两状况同时成立；如：<code>test -r filename -a -x filename</code>，则 file 同时具有 r 与 x 权限时才为 true</td>
</tr>
<tr>
<td align="center">-o</td>
<td align="left">（or）任意一个成立。如：<code>test -r filename -o -x filename</code>，则 file 具有 r 或 x 权限时就为 true</td>
</tr>
<tr>
<td align="center">!</td>
<td align="left">反向状态</td>
</tr>
</tbody></table>
<h2 id="脚本执行方式差异"><a href="#脚本执行方式差异" class="headerlink" title="脚本执行方式差异"></a>脚本执行方式差异</h2><p><strong>.&#x2F;script 或者 sh script执行</strong>：运行脚本时都会使用一个新的 bash 环境，即子程序的 bash 内执行。当子程序完成后，子程序内的各项变量或动作将会结束，不会传回到父程序中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行上面范例的姓名打印</span></span><br><span class="line">[mrcode@study bin]$ ./showname.sh </span><br><span class="line">Please input you first name: m</span><br><span class="line">Please input you last name: q</span><br><span class="line"></span><br><span class="line"> Your full name is: mq		<span class="comment">#  echo -e &quot;\n Your full name is: $&#123;firstname&#125;$&#123;lastname&#125;&quot; 打印出来了信息</span></span><br><span class="line">[mrcode@study bin]$ <span class="built_in">echo</span> <span class="variable">$&#123;fristname&#125;</span><span class="variable">$&#123;lastname&#125;</span>		<span class="comment"># 但是在父程序中却没有信息</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>source 执行</strong>：同样的测试代码，使用 source 则会在父程序中执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[mrcode@study bin]$ <span class="built_in">source</span> showname.sh </span><br><span class="line">Please input you first name: m</span><br><span class="line">Please input you last name: q</span><br><span class="line"></span><br><span class="line"> Your full name is: mq</span><br><span class="line">[mrcode@study bin]$ <span class="built_in">echo</span> <span class="variable">$&#123;firstname&#125;</span><span class="variable">$&#123;lastname&#125;</span></span><br><span class="line">mq			<span class="comment"># 在父程序中还能获取到</span></span><br></pre></td></tr></table></figure>

<h2 id="脚本练习"><a href="#脚本练习" class="headerlink" title="脚本练习"></a>脚本练习</h2><h3 id="利用-date-进行文件的建立"><a href="#利用-date-进行文件的建立" class="headerlink" title="利用 date 进行文件的建立"></a>利用 date 进行文件的建立</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program: </span></span><br><span class="line"><span class="comment">#       用户输入文件名前缀，生成前天、昨天、今天的三个空文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;将使用 ‘touch’ 命令创建 3 个文件&quot;</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入文件名：&quot;</span> fileuser</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容错，使用变量功能判定与赋值默认值</span></span><br><span class="line">filename=<span class="variable">$&#123;fileuser:-&quot;filename&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># date 命令的使用</span></span><br><span class="line">date1=$(<span class="built_in">date</span> --<span class="built_in">date</span>=<span class="string">&#x27;2 days ago&#x27;</span> +%Y-%m-%d)		<span class="comment"># 两天前的日期，并格式化显示</span></span><br><span class="line">date2=$(<span class="built_in">date</span> --<span class="built_in">date</span>=<span class="string">&#x27;1 days ago&#x27;</span> +%Y-%m-%d)	</span><br><span class="line">date3=$(<span class="built_in">date</span> +%Y-%m-%d)</span><br><span class="line"></span><br><span class="line">file1=<span class="string">&quot;<span class="variable">$&#123;filename&#125;</span>_<span class="variable">$&#123;date1&#125;</span>&quot;</span></span><br><span class="line">file2=<span class="string">&quot;<span class="variable">$&#123;filename&#125;</span>_<span class="variable">$&#123;date2&#125;</span>&quot;</span></span><br><span class="line">file3=<span class="string">&quot;<span class="variable">$&#123;filename&#125;</span>_<span class="variable">$&#123;date3&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这里其实可以直接拼接文件名</span></span><br><span class="line"><span class="built_in">touch</span> <span class="string">&quot;<span class="variable">$&#123;file1&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">touch</span> <span class="string">&quot;<span class="variable">$&#123;file2&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">touch</span> <span class="string">&quot;<span class="variable">$&#123;file3&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="数值运算：简单的加减乘除"><a href="#数值运算：简单的加减乘除" class="headerlink" title="数值运算：简单的加减乘除"></a>数值运算：简单的加减乘除</h3><p>在Linux变量中，需要使用 <code>declare</code>来定义变量为正数才能进行计算，此外，也可以利用 <code>$((计算表达式))</code> 来进行数值运算，可惜的是，bashe shell 预设仅支持整数数据。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       用户输入 2 个整数；输出相乘后的结果</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&#x27;请输入第一个整数：&#x27;</span> intUser1</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&#x27;请输入第二个整数：&#x27;</span> intUser2</span><br><span class="line"><span class="built_in">declare</span> -i int1=<span class="variable">$&#123;intUser1&#125;</span></span><br><span class="line"><span class="built_in">declare</span> -i int2=<span class="variable">$&#123;intUser2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e  <span class="string">&quot;\n <span class="variable">$&#123;int1&#125;</span> x <span class="variable">$&#123;int2&#125;</span> = <span class="subst">$((int1*int2)</span>)&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="多重、复杂条件判断"><a href="#多重、复杂条件判断" class="headerlink" title="多重、复杂条件判断"></a>多重、复杂条件判断</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       直接携带参数提示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;hello&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Hello, how ary you?&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;请携带参数&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;只能携带参数 hello&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h3 id="利用-case-esac-判断"><a href="#利用-case-esac-判断" class="headerlink" title="利用 case...esac 判断"></a>利用 <code>case...esac</code> 判断</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       直接携带参数提示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">	<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;Hello, how ary you?&quot;</span></span><br><span class="line">	;;</span><br><span class="line">	<span class="string">&quot;&quot;</span>)</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;请携带参数&quot;</span></span><br><span class="line">	;;</span><br><span class="line">	*)</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;只能携带参数 hello&quot;</span></span><br><span class="line">	;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 常用命令</title>
    <url>/2017/07/05/linux_cmd/</url>
    <content><![CDATA[<h1 id="文件目录管理"><a href="#文件目录管理" class="headerlink" title="文件目录管理"></a>文件目录管理</h1><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>grep命令用于在文本中执行关键词搜索，并显示匹配的结果，格式为“grep [选项] [文件]”。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-b</td>
<td>将可执行文件(binary)当作文本文件（text）来搜索</td>
</tr>
<tr>
<td>-c</td>
<td>仅显示找到的行数</td>
</tr>
<tr>
<td>-i</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>-n</td>
<td>显示行号</td>
</tr>
<tr>
<td>-v</td>
<td>反向选择——仅列出没有“关键词”的行。</td>
</tr>
<tr>
<td>-A</td>
<td>除了显示符合范本样式的那一行之外，并显示该行之后的内容。</td>
</tr>
<tr>
<td>-B</td>
<td>在显示符合范本样式的那一行之外，并显示该行之前的内容。</td>
</tr>
<tr>
<td>-C</td>
<td>除了显示符合范本样式的那一列之外，并显示该列之前后的内容。</td>
</tr>
</tbody></table>
<h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">localhost% <span class="built_in">cat</span> test.txt</span><br><span class="line">NAME    STATUS   ROLES                    AGE   VERSION   INTERNAL-IP    EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION          CONTAINER-RUNTIME</span><br><span class="line">k8s01   Ready    wise-controller          38d   v1.16.4   192.168.0.3    &lt;none&gt;        CentOS                  3.10.0-862.el7.x86_64   docker://18.9.8</span><br><span class="line">k8s02   Ready    wise-controller          38d   v1.16.4   192.168.0.7    &lt;none&gt;        CentOS                  3.10.0-862.el7.x86_64   docker://18.9.8</span><br><span class="line">k8s03   Ready    wise-controller          38d   v1.16.4   192.168.0.10   &lt;none&gt;        CentOS                  3.10.0-862.el7.x86_64   docker://18.9.8</span><br><span class="line">k8s04   NotReady node                     38d   v1.16.4   192.168.0.15   &lt;none&gt;        CentOS                  3.10.0-862.el7.x86_64   docker://18.9.8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印文件的第一列和第五列</span></span><br><span class="line">localhost% awk <span class="string">&#x27;&#123;print $1,$5&#125;&#x27;</span> test.txt</span><br><span class="line">NAME VERSION</span><br><span class="line">k8s01 v1.16.4</span><br><span class="line">k8s02 v1.16.4</span><br><span class="line">k8s03 v1.16.4</span><br><span class="line">k8s04 v1.16.4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印最后一列字段</span></span><br><span class="line">localhost% awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span> test.txt</span><br><span class="line">CONTAINER-RUNTIME</span><br><span class="line">docker://18.9.8</span><br><span class="line">docker://18.9.8</span><br><span class="line">docker://18.9.8</span><br><span class="line">docker://18.9.8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印倒数第二列字段：</span></span><br><span class="line">localhost% awk <span class="string">&#x27;&#123;print $(NF-1)&#125;&#x27;</span> test.txt</span><br><span class="line">KERNEL-VERSION</span><br><span class="line">3.10.0-862.el7.x86_64</span><br><span class="line">3.10.0-862.el7.x86_64</span><br><span class="line">3.10.0-862.el7.x86_64</span><br><span class="line">3.10.0-862.el7.x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印文本文件的总行数</span></span><br><span class="line">localhost% awk <span class="string">&#x27;END&#123;print NR&#125;&#x27;</span> test.txt</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印文本第1行数据</span></span><br><span class="line">localhost% awk <span class="string">&#x27;NR==1&#123;print&#125;&#x27;</span> test.txt</span><br><span class="line">NAME    STATUS   ROLES                    AGE   VERSION   INTERNAL-IP    EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION          CONTAINER-RUNTIME</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印文本大于第1行的数据</span></span><br><span class="line">localhost% awk <span class="string">&#x27;NR&gt;1&#123;print&#125;&#x27;</span> test.txt</span><br><span class="line">k8s01   Ready    wise-controller          38d   v1.16.4   192.168.0.3    &lt;none&gt;        CentOS                  3.10.0-862.el7.x86_64   docker://18.9.8</span><br><span class="line">k8s02   Ready    wise-controller          38d   v1.16.4   192.168.0.7    &lt;none&gt;        CentOS                  3.10.0-862.el7.x86_64   docker://18.9.8</span><br><span class="line">k8s03   Ready    wise-controller          38d   v1.16.4   192.168.0.10   &lt;none&gt;        CentOS                  3.10.0-862.el7.x86_64   docker://18.9.8</span><br><span class="line">k8s04   NotReady node                     38d   v1.16.4   192.168.0.15   &lt;none&gt;        CentOS                  3.10.0-862.el7.x86_64   docker://18.9.8</span><br></pre></td></tr></table></figure>

<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p>定位到数据行并对数据进行增删改查操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 替换文本中的字符串：</span></span><br><span class="line">sed <span class="string">&#x27;s/book/books/&#x27;</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用后缀/g标记会替换每一行中的所有匹配：</span></span><br><span class="line">[root@harbor image_pull_push]# <span class="built_in">cat</span> img-list.txt |sed <span class="string">&#x27;s/registry.cn-hangzhou.aliyuncs.com/192.168.0.11/g&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当需要从第N处匹配配开始替换时，可以使用 /Ng：</span></span><br><span class="line"><span class="built_in">echo</span> sksksksksksk | sed <span class="string">&#x27;s/sk/SK/3g&#x27;</span></span><br><span class="line">skskSKSKSKSK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换某目录下所有文件的某字符串</span></span><br><span class="line">oldip=172.22.12.241</span><br><span class="line">newip=172.22.12.242</span><br><span class="line"><span class="comment"># 查看之前包含oldip的文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f | xargs grep <span class="variable">$oldip</span></span><br><span class="line"><span class="comment"># 替换IP地址</span></span><br><span class="line">find . -<span class="built_in">type</span> f | xargs sed -i <span class="string">&quot;s/<span class="variable">$oldip</span>/<span class="variable">$newip</span>/&quot;</span></span><br><span class="line"><span class="comment"># 检查更新后的</span></span><br><span class="line">find . -<span class="built_in">type</span> f | xargs grep <span class="variable">$newip</span></span><br></pre></td></tr></table></figure>

<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>find命令用于按照指定条件来查找文件，格式为“find [查找路径] 寻找条件 操作”。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-name</td>
<td>匹配名称</td>
</tr>
<tr>
<td>-perm</td>
<td>匹配权限（mode为完全匹配，-mode为包含即可）</td>
</tr>
<tr>
<td>-user</td>
<td>匹配所有者</td>
</tr>
<tr>
<td>-group</td>
<td>匹配所有组</td>
</tr>
<tr>
<td>-mtime -n +n</td>
<td>匹配修改内容的时间（-n指n天以内，+n指n天以前）</td>
</tr>
<tr>
<td>-atime -n +n</td>
<td>匹配访问文件的时间（-n指n天以内，+n指n天以前）</td>
</tr>
<tr>
<td>-ctime -n +n</td>
<td>匹配修改文件权限的时间（-n指n天以内，+n指n天以前）</td>
</tr>
<tr>
<td>-nouser</td>
<td>匹配无所有者的文件</td>
</tr>
<tr>
<td>-nogroup</td>
<td>匹配无所有组的文件</td>
</tr>
<tr>
<td>-newer f1 !f2</td>
<td>匹配比文件f1新但比f2旧的文件</td>
</tr>
<tr>
<td>-type b&#x2F;d&#x2F;c&#x2F;p&#x2F;l&#x2F;f</td>
<td>匹配文件类型（后面的字幕字母依次表示块设备、目录、字符设备、管道、链接文件、文本文件）</td>
</tr>
<tr>
<td>-size</td>
<td>匹配文件的大小（+50KB为查找超过50KB的文件，而-50KB为查找小于50KB的文件）</td>
</tr>
<tr>
<td>-prune</td>
<td>忽略某个目录</td>
</tr>
<tr>
<td>-exec …… {};</td>
<td>后面可跟用于进一步处理搜索结果的命令（下文会有演示）</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录下是否存在README.md </span></span><br><span class="line">find . -name README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找etc目录是否存在以host开头的文件</span></span><br><span class="line">find /etc -name host* </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定目录查找大于1G的文件</span></span><br><span class="line">find / -size +1024M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录搜索所有文件，文件内容 包含 “140.206.111.111” 的内容</span></span><br><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*&quot;</span> | xargs grep <span class="string">&quot;140.206.111.111&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建带有内容的文件</span></span><br><span class="line">[root@harbor ~]# <span class="built_in">echo</span> hello &gt; new.yaml</span><br><span class="line">[root@harbor ~]# <span class="built_in">cat</span> new.yaml</span><br><span class="line">hello</span><br><span class="line"><span class="comment"># 追加写入文件</span></span><br><span class="line">[root@harbor ~]# <span class="built_in">echo</span> hello-test &gt;&gt; new.yaml</span><br><span class="line">[root@harbor ~]# <span class="built_in">cat</span> new.yaml</span><br><span class="line">hello</span><br><span class="line">hello-test</span><br></pre></td></tr></table></figure>

<h2 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h2><p>dd命令用于按照指定大小和个数的数据块来复制文件或转换文件，格式为“dd [参数]”。</p>
<p>Linux系统中有一个名为&#x2F;dev&#x2F;zero的设备文件，这个文件不会占用系统存储空间，但却可以提供无穷无尽的数据，因此可以使用它作为dd命令的输入文件，来生成一个指定大小的文件。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>if</td>
<td>输入的文件名称，如果不指定if，默认就会从stdin中读取输入。</td>
</tr>
<tr>
<td>of</td>
<td>输出的文件名称，如果不指定of，默认就会将stdout作为默认输出。</td>
</tr>
<tr>
<td>bs</td>
<td>设置每个“块”的大小</td>
</tr>
<tr>
<td>count</td>
<td>设置要复制“块”的个数</td>
</tr>
</tbody></table>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从/dev/zero设备文件中取出一个大小为100M的数据块</span></span><br><span class="line">[root@master01 ~]# <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=sun.txt bs=100M count=1</span><br><span class="line">1+0 records <span class="keyword">in</span></span><br><span class="line">1+0 records out</span><br><span class="line">104857600 bytes (105 MB, 100 MiB) copied, 0.0580656 s, 1.8 GB/s</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试磁盘写入速度</span></span><br><span class="line">[root@localhost ~]# dd if=/dev/zero of=/tmp/testfile bs=1G count=1 oflag=direct</span><br><span class="line">1+0 records in</span><br><span class="line">1+0 records out</span><br><span class="line">1073741824 bytes (1.1 GB) copied, 7.10845 s, 151 MB/s</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试磁盘读取速度</span></span><br><span class="line">[root@localhost ~]# dd if=/tmp/testfile of=/dev/null bs=1G count=1 iflag=direct</span><br><span class="line">1+0 records in</span><br><span class="line">1+0 records out</span><br><span class="line">1073741824 bytes (1.1 GB) copied, 6.53009 s, 164 MB/s</span><br></pre></td></tr></table></figure>

<h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>tar命令用于对文件进行打包压缩或解压，格式为“tar [选项] [文件]”。在Linux系统中，常见的文件格式比较多，其中主要使用的是.tar或.tar.gz或.tar.bz2格式。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>创建压缩文件</td>
</tr>
<tr>
<td>-x</td>
<td>解开压缩文件</td>
</tr>
<tr>
<td>-t</td>
<td>查看压缩包内有哪些文件</td>
</tr>
<tr>
<td>-z</td>
<td>用Gzip压缩或解压</td>
</tr>
<tr>
<td>-j</td>
<td>用bzip2压缩或解压</td>
</tr>
<tr>
<td>-v</td>
<td>显示压缩或解压的过程</td>
</tr>
<tr>
<td>-f</td>
<td>目标文件名</td>
</tr>
<tr>
<td>-p</td>
<td>保留原始的权限与属性</td>
</tr>
<tr>
<td>-P</td>
<td>使用绝对路径来压缩</td>
</tr>
<tr>
<td>-C</td>
<td>指定解压到的目录</td>
</tr>
</tbody></table>
<p>命令示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仅打包，不压缩！将 /home/vivek/bin/ 目录打包</span></span><br><span class="line">tar -cvf /tmp/bin-backup.tar /home/vivek/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包 并使用 bzip2 算法压缩压缩</span></span><br><span class="line">tar -jcvf /tmp/bin-backup.tar.bz2 /home/vivek/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包 并使用 gzip 算法压缩压缩</span></span><br><span class="line">tar -zcvf /tmp/bin-backup.tar.gz /home/vivek/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩</span></span><br><span class="line">tar -zxvf bin-backup.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 详细列举包里的所有文件</span></span><br><span class="line">tar -tvf /opt/extra.tgz</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">上下翻页：Ctrl+f、Ctrl+b</span><br><span class="line">跳到当前行最后字符处：Fn+右键</span><br><span class="line">跳到当前行最前面字符处：Fn+左键、0</span><br><span class="line"></span><br><span class="line">查找字符串：/字符串  n继续查找</span><br><span class="line">字符全局替换：:%s/foo/bar/g  :&#123;作用范围&#125;s/&#123;目标&#125;/&#123;替换&#125;/&#123;替换标志&#125;</span><br><span class="line"></span><br><span class="line">x或X：删除一个字符，x删除光标后的，而X删除光标前的；</span><br><span class="line">D：删除从当前光标到光标所在行尾的全部字符；</span><br><span class="line">删除行：<span class="built_in">dd</span> ndd（n代表删除或复制的行数）</span><br><span class="line">复制行：yy  nyy</span><br><span class="line">粘贴行：p、P</span><br><span class="line"></span><br><span class="line">复原前一个操作：u</span><br><span class="line">重做上一个操作：ctrl+r</span><br><span class="line">显示行号：:<span class="built_in">set</span> nu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ctrl+u：向文件首翻半屏；</span><br><span class="line">Ctrl+d：向文件尾翻半屏；</span><br><span class="line">Ctrl+f：向文件尾翻一屏；</span><br><span class="line">Ctrl+b：向文件首翻一屏；</span><br><span class="line">Esc：从编辑模式切换到命令模式；</span><br><span class="line">ZZ：命令模式下保存当前文件所做的修改后退出vi；</span><br><span class="line">:行号：光标跳转到指定行的行首；</span><br><span class="line">:$：光标跳转到最后一行的行首；</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><p><strong>scp命令</strong> 用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从远程拷贝目录到本地</span></span><br><span class="line">scp -r root@10.10.10.10:/opt/soft/mongodb /opt/soft/ </span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地目录到远程机器指定目录</span></span><br><span class="line">scp -r /opt/soft/mongodb root@10.10.10.10:/opt/soft/scptest</span><br></pre></td></tr></table></figure>

<h2 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h2><p>vi编辑器提供了丰富的内置命令，有些内置命令使用键盘组合键即可完成，有些内置命令则需要以冒号“：”开头输入。</p>
<p>常用内置命令如下：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>dd</td>
<td>删除（剪切）光标所在整行</td>
</tr>
<tr>
<td>5dd</td>
<td>删除（剪切）从光标处开始的5行</td>
</tr>
<tr>
<td>yy</td>
<td>复制光标所在整行</td>
</tr>
<tr>
<td>5yy</td>
<td>复制从光标处开始的5行</td>
</tr>
<tr>
<td>u</td>
<td>撤销上一步的操作</td>
</tr>
<tr>
<td>p</td>
<td>将之前删除（dd）或复制（yy）过的数据粘贴到光标后面</td>
</tr>
<tr>
<td>D</td>
<td>删除光标处所在行尾的全部字符</td>
</tr>
<tr>
<td>x</td>
<td>删除光标处的一个字符</td>
</tr>
<tr>
<td>:set nu</td>
<td>显示行号</td>
</tr>
<tr>
<td>&#x2F;string、?string</td>
<td>查找字符串，常结合n&#x2F;N可以继续查找上一个、下一个字符串</td>
</tr>
<tr>
<td>:s&#x2F;foo&#x2F;bar&#x2F;g</td>
<td>将当前光标所在行的所有foo替换成bar</td>
</tr>
<tr>
<td>:%s&#x2F;foo&#x2F;bar&#x2F;g</td>
<td>将全文中的所有foo替换成bar</td>
</tr>
<tr>
<td>Fn+右键</td>
<td>光标跳到当前行最后一个字符</td>
</tr>
<tr>
<td>Fn+右键、0</td>
<td>光标跳到当前行第一个字符</td>
</tr>
<tr>
<td>Ctrl+f、Ctrl+b</td>
<td>上下翻页</td>
</tr>
</tbody></table>
<h2 id="file"><a href="#file" class="headerlink" title="file"></a>file</h2><p>file命令用于查看文件的类型，格式为“file 文件名”。</p>
<p>在Linux系统中，由于文本、目录、设备等所有这些一切都统称为文件，而我们又不能单凭后缀就知道具体的文件类型，这时就需要使用file命令来查看文件类型了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]# file admin-openrc.sh</span><br><span class="line">admin-openrc.sh: ASCII text</span><br><span class="line"></span><br><span class="line">[root@master01 ~]# file /dev/sda</span><br><span class="line">/dev/sda: block special (8/0)</span><br></pre></td></tr></table></figure>

<h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><p><code>wc</code> 命令用于统计指定文本的行数、字数、字节数，格式为“<code>wc [参数]</code> 文本”。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>-l</code></td>
<td>只显示行数</td>
</tr>
<tr>
<td><code>-w</code></td>
<td>只显示单词数</td>
</tr>
<tr>
<td><code>-c</code></td>
<td>只显示字节数</td>
</tr>
</tbody></table>
<h1 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h1><h2 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h2><p><strong>ip命令</strong> 用来显示或操纵Linux主机的路由、网络设备、策略路由和隧道，是Linux下较新的功能强大的网络配置工具。</p>
<p>网卡配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span>                          <span class="comment"># 显示网络接口信息</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 up              <span class="comment"># 开启网卡</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 down            <span class="comment"># 关闭网卡</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 promisc on      <span class="comment"># 开启网卡的混合模式</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 promisc offi    <span class="comment"># 关闭网卡的混合模式</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 txqueuelen 1200 <span class="comment"># 设置网卡队列长度</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 mtu 1400        <span class="comment"># 设置网卡最大传输单元</span></span><br><span class="line"></span><br><span class="line">ip a                             <span class="comment"># 显示网卡IP信息</span></span><br><span class="line">ip a a 192.168.0.1/24 dev eth0 <span class="comment"># 为eth0网卡添加IP地址192.168.0.1</span></span><br><span class="line">ip a d 192.168.0.1/24 dev eth0 <span class="comment"># 为eth0网卡删除一个IP地址192.168.0.1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>ip命令配置网卡信息，在网卡或机器重启后配置会丢失。要想配置永久生效，那就要修改网卡配置文件。如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件名对应网口名，CentOS 7\8 默认配置文件</span></span><br><span class="line">[Linux]# vi /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">DEVICE=<span class="string">&quot;eth0&quot;</span></span><br><span class="line">BOOTPROTO=<span class="string">&quot;static&quot;</span></span><br><span class="line">BROADCAST=<span class="string">&quot;192.168.0.255&quot;</span></span><br><span class="line">HWADDR=<span class="string">&quot;00:16:36:1B:BB:74&quot;</span></span><br><span class="line">IPADDR=<span class="string">&quot;192.168.0.100&quot;</span></span><br><span class="line">NETMASK=<span class="string">&quot;255.255.255.0&quot;</span></span><br><span class="line">ONBOOT=<span class="string">&quot;yes&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>路由配置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ip r                         <span class="comment"># 显示系统路由</span></span><br><span class="line">ip r add default via 192.168.1.254   <span class="comment"># 设置系统默认路由</span></span><br><span class="line">ip r d default          <span class="comment"># 删除默认路由</span></span><br><span class="line"></span><br><span class="line">ip r a 192.168.4.0/24 via 192.168.0.254 dev eth0 <span class="comment"># 设置192.168.4.0网段的网关为192.168.0.254,数据走eth0接口</span></span><br><span class="line">ip r a default via 192.168.0.254 dev eth0        <span class="comment"># 设置默认网关为192.168.0.254</span></span><br><span class="line">ip r d 192.168.4.0/24   <span class="comment"># 删除192.168.4.0网段的网关</span></span><br><span class="line">ip r d 192.168.1.0/24 dev eth0 <span class="comment"># 删除路由</span></span><br></pre></td></tr></table></figure>

<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>有时进程之间需要通信，需要开启一个socket，socket就是对外建立连接的一个窗口，然后借助TCP协议进行通信。但进行通信之前首先需要进程开启一个端口，这时就可以通过netstat命令查看开启的端口以及由哪个进程开启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#列出所有端口</span></span><br><span class="line">netstat -a</span><br><span class="line"><span class="comment">#列出所有tcp端口</span></span><br><span class="line">netstat -at</span><br><span class="line"><span class="comment">#列出所有udp端口</span></span><br><span class="line">netstat -au</span><br><span class="line"><span class="comment">#只列出所有监听 udp 端口</span></span><br><span class="line">netstat -lu</span><br><span class="line"><span class="comment"># 通过端口找进程ID</span></span><br><span class="line">netstat -anp|grep 8081 | grep LISTEN|awk <span class="string">&#x27;&#123;printf $7&#125;&#x27;</span>|<span class="built_in">cut</span> -d/ -f1</span><br><span class="line"></span><br><span class="line">-n或--numeric：直接使用ip地址，而不通过域名服务器；</span><br><span class="line">-l或--listening：显示监控中的服务器的Socket</span><br><span class="line">-p或--programs：添加“PID/进程名称”到netstat输出中；</span><br></pre></td></tr></table></figure>

<h2 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h2><p>ss 可以用来获取socket统计信息，它可以显示和netstat类似的内容。但ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ss -t -a    <span class="comment"># 显示TCP连接</span></span><br><span class="line">ss -u -a    <span class="comment"># 显示所有UDP Sockets</span></span><br><span class="line">ss -s       <span class="comment"># 显示 Sockets 摘要</span></span><br><span class="line">ss -l       <span class="comment"># 列出所有打开的网络连接端口</span></span><br><span class="line">ss -pl      <span class="comment"># 查看进程使用的socket</span></span><br><span class="line">ss -lp | grep 3306  <span class="comment"># 找出打开套接字/端口应用程序</span></span><br></pre></td></tr></table></figure>

<h1 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h1><h2 id="firewalld-cmd"><a href="#firewalld-cmd" class="headerlink" title="firewalld-cmd"></a>firewalld-cmd</h2><p>firewalld是centos7的一大特性，最大的好处有两个：支持动态更新，不用重启服务；第二个就是加入了防火墙的“zone”概念。</p>
<p>firewalld自身并不具备防火墙的功能，而是和iptables一样需要通过内核的netfilter来实现，也就是说firewalld和 iptables一样，他们的作用都是用于维护规则，而真正使用规则干活的是内核的netfilter，只不过firewalld和iptables的结 构以及使用方法不一样罢了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]# firewall-cmd --zone=public --list-ports</span><br><span class="line">2121/tcp 3306/tcp 8081/tcp 30000/tcp 38060/tcp 40000/tcp 40001/tcp</span><br><span class="line"></span><br><span class="line">[root@master01 ~]# firewall-cmd --permanent --add-port=3307/tcp --zone=public</span><br><span class="line">success</span><br><span class="line"></span><br><span class="line">[root@master01 ~]# firewall-cmd --reload</span><br><span class="line">success</span><br><span class="line"></span><br><span class="line">[root@master01 ~]# firewall-cmd --zone=public --list-ports</span><br><span class="line">2121/tcp 3306/tcp 3307/tcp 8081/tcp 30000/tcp 38060/tcp 40000/tcp 40001/tcp</span><br></pre></td></tr></table></figure>

<p>firewalld中常见的zone（默认为public）以及相应的策略规则如下所示：</p>
<table>
<thead>
<tr>
<th>区域</th>
<th align="left">默认规则策略</th>
</tr>
</thead>
<tbody><tr>
<td>trusted</td>
<td align="left">允许所有的数据包</td>
</tr>
<tr>
<td>home</td>
<td align="left">拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>internal</td>
<td align="left">等同于home区域</td>
</tr>
<tr>
<td>work</td>
<td align="left">拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、ipp-client与dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>public</td>
<td align="left">拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>external</td>
<td align="left">拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td>
</tr>
<tr>
<td>dmz</td>
<td align="left">拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td>
</tr>
<tr>
<td>block</td>
<td align="left">拒绝流入的流量，除非与流出的流量相关</td>
</tr>
<tr>
<td>drop</td>
<td align="left">拒绝流入的流量，除非与流出的流量相关</td>
</tr>
</tbody></table>
<h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p><strong>ps命令</strong> 用于报告当前系统的进程状态。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>显示所有进程（包括其他用户的进程）</td>
</tr>
<tr>
<td>-u</td>
<td>用户以及其他详细信息</td>
</tr>
<tr>
<td>-x</td>
<td>显示没有控制终端的进程</td>
</tr>
</tbody></table>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加上ww可以完整展示进程的信息</span></span><br><span class="line">ps -efww</span><br><span class="line"><span class="comment"># 找出占用内存资源最多的前 10 个进程</span></span><br><span class="line">ps -auxf | <span class="built_in">sort</span> -nr -k 4 | <span class="built_in">head</span> -10</span><br><span class="line"><span class="comment"># 找出占用cpu资源最多的前 10 个进程</span></span><br><span class="line">ps -auxf | <span class="built_in">sort</span> -nr -k 3 | <span class="built_in">head</span> -10 </span><br></pre></td></tr></table></figure>
<h2 id="journalctl"><a href="#journalctl" class="headerlink" title="journalctl"></a>journalctl</h2><p>检索 systemd 日志，是 CentOS 7 才有的工具</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看服务启动日志</span></span><br><span class="line">journalctl -u kubelet.service</span><br><span class="line">journalctl -u etcd.service -f -n 100 </span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果不知道服务名称，可以使用<code>systemctl list-units --type=service</code>命令来列出系统中的 systemd 服务。</p>
</blockquote>
<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p><strong>watch命令</strong> 以周期性的方式执行给定的指令，指令输出以全屏方式显示</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每隔60s查看主机内存的使用情况</span></span><br><span class="line">watch -d -n 60 <span class="string">&quot;free -h&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h2><p><strong>rpm命令</strong> 是RPM软件包的管理工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有安装过的包</span></span><br><span class="line">rpm -qa </span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装rpm软件包</span></span><br><span class="line">rpm -ivh your-package.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取rpm包中的文件安装路径</span></span><br><span class="line">rpm -ql nfs-utils-1.3.0-0.54.el7.x86_64 </span><br></pre></td></tr></table></figure>

<h2 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h2><p><strong>crontab命令</strong> 被用来提交和管理用户的需要周期性执行的任务</p>
<p>用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab文件都被保存在<code>/var/spool/cron</code>目录中。其文件名与用户名一致。</p>
<p>crontab文件的含义：用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minute   hour   day   month   week   command     顺序：分 时 日 月 周</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]# <span class="built_in">cat</span> /var/spool/cron/root</span><br><span class="line"><span class="comment">#Ansible: release free</span></span><br><span class="line">0 * * * * sh /opt/free.sh</span><br><span class="line"><span class="comment">#Ansible: disk check over 85% move vip</span></span><br><span class="line">0 * * * * sh /opt/diskcheck.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出该用户的定时任务</span></span><br><span class="line">[root@master01 ~]# crontab -l</span><br><span class="line"><span class="comment">#Ansible: release free</span></span><br><span class="line">0 * * * * sh /opt/free.sh</span><br><span class="line"><span class="comment">#Ansible: disk check over 85% move vip</span></span><br><span class="line">0 * * * * sh /opt/diskcheck.sh</span><br></pre></td></tr></table></figure>

<h1 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h1><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p><strong>nohup命令</strong> 可以将程序以忽略挂起信号的方式运行起来，被运行的程序的输出信息将不会显示到终端。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后台运行脚本，stderr和stdout重定向输出到output.log</span></span><br><span class="line"><span class="built_in">nohup</span> sh install.sh &gt; output.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<h2 id="script"><a href="#script" class="headerlink" title="script"></a>script</h2><p><strong>script</strong> 用于在终端会话中，记录用户的所有操作和命令的输出信息。</p>
<p>使用命令<code>exit</code>或者快捷键<code>Ctrl + D</code>停止记录。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 静默模式记录</span></span><br><span class="line">script -q myfile</span><br></pre></td></tr></table></figure>

<h2 id="chattr"><a href="#chattr" class="headerlink" title="chattr"></a>chattr</h2><p><strong>chattr命令</strong> 用来改变文件属性。这些属性共有以下8种模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a：让文件或目录仅供附加用途；</span><br><span class="line">b：不更新文件或目录的最后存取时间；</span><br><span class="line">c：将文件或目录压缩后存放；</span><br><span class="line">d：将文件或目录排除在倾倒操作之外；</span><br><span class="line">i：不得任意更动文件或目录；</span><br><span class="line">s：保密性删除文件或目录；</span><br><span class="line">S：即时更新文件或目录；</span><br><span class="line">u：预防意外删除。</span><br><span class="line"></span><br><span class="line">+&lt;属性&gt;：开启文件或目录的该项属性；</span><br><span class="line">-&lt;属性&gt;：关闭文件或目录的该项属性；</span><br><span class="line">=&lt;属性&gt;：指定文件或目录的该项属性。</span><br></pre></td></tr></table></figure>

<p>用chattr命令防止系统中某个关键文件被修改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chattr +i /etc/fstab</span><br></pre></td></tr></table></figure>

<p>然后试一下rm、mv、rename等命令操作于该文件，都是得到Operation not permitted的结果。</p>
<p>让某个文件只能往里面追加内容，不能删除，一些日志文件适用于这种操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chattr +a /var/log/ansible.log</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>网络系列：计算机网络基础知识</title>
    <url>/2021/01/26/network-base/</url>
    <content><![CDATA[<h1 id="TCP-IP-模型"><a href="#TCP-IP-模型" class="headerlink" title="TCP&#x2F;IP 模型"></a>TCP&#x2F;IP 模型</h1><table>
<thead>
<tr>
<th>TCP&#x2F;IP 层级</th>
<th>对应 OSI 层级</th>
<th>功能描述</th>
<th>核心协议</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>L5-L7（会话层、表示层、应用层）</td>
<td>面向用户，处理具体应用需求</td>
<td>HTTP、FTP、DNS、SMTP、SSH</td>
</tr>
<tr>
<td>传输层</td>
<td>L4</td>
<td>确保数据“端到端”可靠传输</td>
<td>TCP、UDP</td>
</tr>
<tr>
<td>网络层</td>
<td>L3</td>
<td>转发和路由</td>
<td>IP、ICMP、ARP、BGP</td>
</tr>
<tr>
<td>链路层</td>
<td>L1-L2（数据链路层、物理层）</td>
<td>物理介质传输比特流</td>
<td>以太网、Wi-Fi、MAC 地址</td>
</tr>
</tbody></table>
<h1 id="常见网络协议"><a href="#常见网络协议" class="headerlink" title="常见网络协议"></a>常见网络协议</h1><h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><p><strong>基本概念</strong></p>
<p>HTTP 是超文本传输协议，也就是<strong>HyperText Transfer Protocol</strong>。具体来说，主要是来规范浏览器和服务器端的行为的。并且，HTTP 是一个无状态（stateless）协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。</p>
<p><strong>常见状态码</strong></p>
<p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p>
<ul>
<li>「<strong>101 Switching Protocols</strong>」协议切换，服务器已经理解了客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求。比如切换到一个实时且同步的协议（如 WebSocket）以传送利用此类特性的资源。</li>
</ul>
<p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求。</p>
<ul>
<li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li>
<li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li>
<li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li>
</ul>
<p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p>
<ul>
<li><p>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</p>
</li>
<li><p>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</p>
</li>
<li><p>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</p>
</li>
</ul>
<p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p>
<ul>
<li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li>
<li>「<strong>401 Unauthorized</strong>」表示客户端请求没有进行验证或验证失败。</li>
<li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li>
<li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到。</li>
</ul>
<p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p>
<ul>
<li>「<strong>500 Internal Server Error</strong>」与 400 类似，是个笼统通用的错误码。</li>
<li>「<strong>501 Not Implemented</strong>」表示请求的方法不被服务器支持。</li>
<li>「<strong>502 Bad Gateway</strong>」表示作为网关或者代理的服务器尝试执行请求时，从上游服务器接收到无效的响应。</li>
<li>「<strong>503 Service Unavailable</strong>」表示服务器尚未处于可以接受请求的状态，类似“网络服务正忙，请稍后重试”的意思。</li>
<li>「<strong>504 Gateway Timeout</strong>」表示作为网关或者代理的服务器无法在规定的时间内，从上游服务器获得想要的响应。</li>
</ul>
<h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a><strong>TCP 协议</strong></h2><p><strong>基本概念</strong></p>
<p>TCP 的全称叫传输控制协议（<em>Transmission Control Protocol</em>），</p>
<p><strong>特点</strong></p>
<p>面向连接、可靠传输（流量控制、超时重传、拥塞控制）  、基于字节流。</p>
<p><strong>端口号</strong></p>
<p>一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是<strong>端口</strong>。比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。</p>
<h2 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a><strong>UDP 协议</strong></h2><p><strong>基本概念</strong></p>
<p>UDP（User Datagram Protocol）是一个简单的面向消息的传输层协议。UDP 只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，则必须在用户应用程序中实现。</p>
<p><strong>特点</strong></p>
<p>无连接、不可靠、低延迟</p>
<h2 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h2><p><strong>基本概念</strong></p>
<p>网络层最常使用的是 IP 协议（<em>Internet Protocol</em>），IP 协议会将传输层的报文作为数据部分，再加上 IP 报头组装成 IP 报文，以便它们可以跨网络传播并到达正确的目的地。如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p>
<p><strong>子网</strong></p>
<p>IP 协议使用 <strong>IP 地址</strong> 来区分互联网上的每一台设备。但是一个单纯的 IP 地址，<strong>寻址</strong>起来还是特别麻烦，全世界那么多台设备，难道一个一个去匹配？这就产生了<strong>子网</strong>的概念，即寻址过程中，先要匹配找到同一个子网，才会去找对应的主机。</p>
<p><strong>路由</strong></p>
<p>IP 协议另一个重要的能力就是<strong>路由</strong>。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径。<strong>路由器</strong>寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。</p>
<h1 id="计算机网络面试题"><a href="#计算机网络面试题" class="headerlink" title="计算机网络面试题"></a>计算机网络面试题</h1><h2 id="HTTP-1-1-的优点有哪些"><a href="#HTTP-1-1-的优点有哪些" class="headerlink" title="HTTP&#x2F;1.1 的优点有哪些"></a>HTTP&#x2F;1.1 的优点有哪些</h2><p><em><strong>1. 简单</strong></em></p>
<p>HTTP 基本的报文格式就是 <code>header + body</code>，头部信息也是 <code>key-value</code> 简单文本的形式，<strong>易于理解</strong>，降低了学习和使用的门槛。</p>
<p><em><strong>2. 灵活和易于扩展</strong></em></p>
<p>HTTP 协议里的各类请求方法、URI&#x2F;URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员<strong>自定义和扩充</strong>。</p>
<p>同时 HTTP 由于是工作在应用层（ <code>OSI</code> 第七层），则它<strong>下层可以随意变化</strong>，比如 HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL&#x2F;TLS 安全传输层；</p>
<p><em><strong>3. 应用广泛和跨平台</strong></em></p>
<p>互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，HTTP 的应用遍地开花，同时天然具有<strong>跨平台</strong>的优越性。</p>
<h2 id="HTTP-1-1-的缺点有哪些"><a href="#HTTP-1-1-的缺点有哪些" class="headerlink" title="HTTP&#x2F;1.1 的缺点有哪些"></a>HTTP&#x2F;1.1 的缺点有哪些</h2><p>HTTP 协议里有优缺点一体的双刃剑，分别是「<strong>无状态</strong>、<em><strong>队头阻塞</strong></em>」，同时还有一大缺点「<strong>不安全</strong>」。</p>
<p><strong>1.无状态</strong></p>
<p>HTTP协议的无状态特性意味着服务器不会记录客户端的请求历史，每个请求都被视为独立且无关的。这一设计虽然简化了服务器实现并提升了处理效率，但也带来了以下主要问题：</p>
<ul>
<li>无法直接识别客户端：服务器无法直接识别客户端，每次都要进行用户身份验证和授权，导致用户登录、个性化推荐等关联功能难以实现。</li>
<li>重复传输大量信息：每个请求都要重复传输大量相同的信息，如Host、Authentication、Cookies等元数据，增加了数据传输量和服务器的处理负担。</li>
</ul>
<p><strong>2.队头拥塞</strong></p>
<p>「请求 - 应答」的模式加剧了 HTTP 的性能问题。</p>
<p>因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「<strong>队头阻塞</strong>」。</p>
<p><strong>3.不安全</strong></p>
<p>HTTP 比较严重的缺点就是不安全：</p>
<ul>
<li>通信使用明文（不加密），内容可能会被窃听。</li>
<li>不验证通信方的身份，因此有可能遭遇伪装。</li>
<li>无法证明报文的完整性，所以有可能已遭篡改。</li>
</ul>
<h2 id="怎么解决-HTTP-请求无状态带来的问题"><a href="#怎么解决-HTTP-请求无状态带来的问题" class="headerlink" title="怎么解决 HTTP 请求无状态带来的问题"></a>怎么解决 HTTP 请求无状态带来的问题</h2><h3 id="1-Cookie机制"><a href="#1-Cookie机制" class="headerlink" title="1. Cookie机制"></a>1. <strong>Cookie机制</strong></h3><img src="/2021/01/26/network-base/640.png"  alt="cookie技术" style="zoom: 50%;" />

<ul>
<li><strong>原理</strong>：服务器通过响应头的<code>Set-Cookie</code>字段向客户端写入键值对数据，客户端后续请求时携带这些Cookie，从而使服务器能够识别并跟踪用户会话。</li>
<li><strong>局限</strong>：<ul>
<li>数据存储在客户端，存在安全风险（如XSS攻击窃取Cookie）。</li>
<li>单个域名下Cookie大小受限（通常4KB），且每次请求均会携带，可能影响性能</li>
</ul>
</li>
</ul>
<h3 id="2-Session机制"><a href="#2-Session机制" class="headerlink" title="2. Session机制"></a>2. <strong>Session机制</strong></h3><img src="/2021/01/26/network-base/image.png"  alt="image" style="zoom:50%;" />

<ul>
<li><strong>原理</strong>：服务器创建唯一Session ID并将其发送给客户端（通常通过Cookie传递），并将用户状态存储在服务端（如内存、数据库）。在后续的请求中，客户端会携带Session ID，服务器根据Session ID在服务器端检索对应的会话状态。</li>
<li><strong>优势</strong>：状态数据存储在服务端，安全性较高，适合保存敏感信息（如用户权限）。</li>
<li><strong>局限</strong>：<ul>
<li>服务器需维护Session存储（比如会话同步），高并发场景下可能产生性能瓶颈，且在分布式系统中会限制负载均衡的能力。</li>
<li>Session ID依赖Cookie传递，若客户端禁用Cookie则需通过URL重写实现。</li>
</ul>
</li>
</ul>
<h3 id="3-Token机制"><a href="#3-Token机制" class="headerlink" title="3. Token机制"></a>3. <strong>Token机制</strong></h3><ul>
<li><strong>原理</strong>：服务器生成包含用户信息的令牌（如JWT），客户端在请求头（如<code>Authorization</code>）中携带该令牌。客户端每次请求时携带该Token，服务器验证后获取用户信息，服务器无需存储会话数据。</li>
<li><strong>优势</strong>：<ul>
<li>无状态设计减轻服务器压力，适合分布式系统。</li>
<li>支持跨域场景和多种客户端（如移动端App）</li>
</ul>
</li>
<li><strong>局限</strong>：令牌需定期更新以防止泄露，且需处理令牌吊销问题</li>
</ul>
<h3 id="4-其他优化技术"><a href="#4-其他优化技术" class="headerlink" title="4. 其他优化技术"></a>4. <strong>其他优化技术</strong></h3><ul>
<li><strong>持久连接（Keep-Alive）</strong> ：HTTP&#x2F;1.1默认启用，通过复用TCP连接减少握手开销，间接提升状态相关请求的效率（虽不直接解决无状态问题）。</li>
<li><strong>缓存机制</strong>：利用强制缓存（如<code>Cache-Control</code>）和协商缓存（如<code>ETag</code>）减少重复数据传输，缓解无状态导致的冗余问题</li>
</ul>
<h2 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h2><ul>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输（通常是对称加密数据）。</li>
<li>HTTP 连接建立相对简单，TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 比 HTTP 多了 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li>
<li><strong>端口号</strong>：HTTP 默认是 80，HTTPS 默认是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ul>
<h2 id="从输入-URL-到页面展示到底发生了什么？"><a href="#从输入-URL-到页面展示到底发生了什么？" class="headerlink" title="从输入 URL 到页面展示到底发生了什么？"></a>从输入 URL 到页面展示到底发生了什么？</h2><ol>
<li>在浏览器中输入指定网页的 URL。</li>
<li>浏览器通过 DNS 协议，获取域名对应的 IP 地址。</li>
<li>浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求（创建套接字 Socket）。</li>
<li>浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。</li>
<li>服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。</li>
<li>浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。</li>
<li>浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</li>
</ol>
<h2 id="ARP地址解析协议的工作过程"><a href="#ARP地址解析协议的工作过程" class="headerlink" title="ARP地址解析协议的工作过程"></a>ARP地址解析协议的工作过程</h2><p><strong>广播发送ARP请求，单播发送ARP响应。</strong></p>
<ol>
<li>首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表（通过<code>arp -n</code>查找），以表示IP地址和MAC地址之间的对应关系。</li>
<li>当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。</li>
<li>当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</li>
<li>源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</li>
</ol>
<img src="/2021/01/26/network-base/2378e655-5580-4f80-b2fc-138287c17ea2.png"  alt="2378e655-5580-4f80-b2fc-138287c17ea2" style="zoom:50%;" />

<h2 id="DNS-的作用是什么？"><a href="#DNS-的作用是什么？" class="headerlink" title="DNS 的作用是什么？"></a>DNS 的作用是什么？</h2><p>DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是<strong>域名和 IP 地址的映射问题</strong>。</p>
<h2 id="DNS进行域名解析的过程"><a href="#DNS进行域名解析的过程" class="headerlink" title="DNS进行域名解析的过程"></a>DNS进行域名解析的过程</h2><ol>
<li>简单来说，当在浏览器地址栏中输入某个Web服务器的域名时。主机会发出一个DNS请求到<strong>本地DNS服务器</strong>（也就是客户端 TCP&#x2F;IP 设置中填写的 DNS 服务器地址）。</li>
<li><strong>本地DNS服务器</strong>会首先查询高速缓存记录，如果缓存中有此条记录，就可以直接返回结果。若没有查到，本地DNS则将请求发给根域DNS服务器。</li>
<li>根DNS服务器并不会记录域名和IP地址的对应关系，只会“指路”；即告知<strong>本地DNS</strong>去迭代查找至顶级域、二级域（.com 、.org），三级域，直至找到要解析的IP地址</li>
<li><strong>本地DNS</strong> 再将IP地址返回给客户端，客户端与目标成功建立连接。同时把对应关系保存在缓存中，加快网络访问。</li>
</ol>
<img src="/2021/01/26/network-base/1715326531135-c1f081dd-89e1-4b31-94e4-95a76f9fcba4.png"  alt="img" style="zoom: 33%;" />

<p>更详细的总结：</p>
<p>浏览器缓存——》系统hosts文件——》本地DNS解析器缓存——》本地域名服务器（本地配置区域资源、本地域名服务器缓存)——》根域名服务器——》主域名服务器——》下一级域名域名服务器 客户端——》本地域名服务器（递归查询) 本地域名服务器—》DNS服务器的交互查询是迭代查询</p>
<h2 id="TCP连接是怎么建立和断开的"><a href="#TCP连接是怎么建立和断开的" class="headerlink" title="TCP连接是怎么建立和断开的"></a>TCP连接是怎么建立和断开的</h2><p>建立一个 TCP 连接需要“三次握手”，缺一不可：</p>
<ul>
<li><strong>一次握手</strong>:客户端发送带有 SYN（SEQ&#x3D;x） 标志的数据包 -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务端的确认；</li>
<li><strong>二次握手</strong>:服务端发送带有 SYN+ACK(SEQ&#x3D;y,ACK&#x3D;x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong> 状态；</li>
<li><strong>三次握手</strong>:客户端发送带有 ACK(ACK&#x3D;y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务端都进入<strong>ESTABLISHED</strong> 状态，完成 TCP 三次握手。</li>
</ul>
<p>断开一个 TCP 连接则需要“四次挥手”，缺一不可：</p>
<ol>
<li><strong>第一次挥手</strong>：客户端发送一个 FIN（SEQ&#x3D;x） 标志的数据包-&gt;服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li>
<li><strong>第二次挥手</strong>：服务端收到这个 FIN（SEQ&#x3D;X） 标志的数据包，它发送一个 ACK （ACK&#x3D;x+1）标志的数据包-&gt;客户端 。然后服务端进入 <strong>CLOSE-WAIT</strong> 状态，客户端进入 <strong>FIN-WAIT-2</strong> 状态。</li>
<li><strong>第三次挥手</strong>：服务端发送一个 FIN (SEQ&#x3D;y)标志的数据包-&gt;客户端，请求关闭连接，然后服务端进入 <strong>LAST-ACK</strong> 状态。</li>
<li><strong>第四次挥手</strong>：客户端发送 ACK (ACK&#x3D;y+1)标志的数据包-&gt;服务端，然后客户端进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (ACK&#x3D;y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。</li>
</ol>
<h2 id="WebSocket-和-HTTP-有什么区别"><a href="#WebSocket-和-HTTP-有什么区别" class="headerlink" title="WebSocket 和 HTTP 有什么区别"></a>WebSocket 和 HTTP 有什么区别</h2><p>WebSocket 和 HTTP 两者都是基于 TCP 的应用层协议，都可以在网络中传输数据。</p>
<p>下面是二者的主要区别：</p>
<ul>
<li>WebSocket 是一种双向实时通信协议，而 HTTP 是一种单向通信协议。并且，HTTP 协议下的通信只能由客户端发起，服务器无法主动通知客户端。</li>
<li>WebSocket 使用 ws:&#x2F;&#x2F; 或 wss:&#x2F;&#x2F;（使用 SSL&#x2F;TLS 加密后的协议，类似于 HTTP 和 HTTPS 的关系） 作为协议前缀，HTTP 使用 http:&#x2F;&#x2F; 或 https:&#x2F;&#x2F; 作为协议前缀。</li>
<li>WebSocket 可以支持扩展，用户可以扩展协议，实现部分自定义的子协议，如支持压缩、加密等。</li>
<li>WebSocket 通信数据格式比较轻量，用于协议控制的数据包头部相对较小，网络开销小，而 HTTP 通信每次都要携带完整的头部，网络开销较大（HTTP&#x2F;2.0 使用二进制帧进行数据传输，还支持头部压缩，减少了网络开销）。</li>
</ul>
<h2 id="什么时候选择-TCP，什么时候选-UDP"><a href="#什么时候选择-TCP，什么时候选-UDP" class="headerlink" title="什么时候选择 TCP，什么时候选 UDP"></a>什么时候选择 TCP，什么时候选 UDP</h2><p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p>
<ul>
<li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li>
<li>视频、音频等多媒体通信；</li>
<li>广播通信；</li>
</ul>
<p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p>
<ul>
<li><code>FTP</code> 文件传输；</li>
<li>HTTP &#x2F; HTTPS；</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>网络系列：常用网络设备</title>
    <url>/2021/02/07/network-device/</url>
    <content><![CDATA[<h1 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h1><table>
<thead>
<tr>
<th>设备</th>
<th>工作层级</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>集线器</strong></td>
<td>L1</td>
<td>广播数据包到所有端口，无智能过滤</td>
</tr>
<tr>
<td><strong>交换机</strong></td>
<td>L2</td>
<td>基于 MAC 地址对数据帧进行转发，支持 VLAN 划分</td>
</tr>
<tr>
<td><strong>路由器</strong></td>
<td>L3</td>
<td>基于 IP 地址路由数据包（Packet），隔离广播域，支持 NAT 和防火墙</td>
</tr>
<tr>
<td><strong>三层交换机</strong></td>
<td>L3</td>
<td>结合交换机和路由器的功能，高速转发并支持路由策略</td>
</tr>
</tbody></table>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a><strong>交换机</strong></h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>交换机根据每个<strong>端口</strong>接收到的数据帧源地址进行<strong>MAC地址学习</strong>，内部维护一张<strong>MAC地址表</strong>。在后续的通讯中，发往特定MAC地址的数据包仅被转发至该MAC地址对应的端口，而非所有端口。</p>
<h3 id="MAC-地址表建立过程"><a href="#MAC-地址表建立过程" class="headerlink" title="MAC 地址表建立过程"></a><strong>MAC 地址表建立过程</strong></h3><p>初始状态下，交换机的MAC地址表为空。</p>
<ol>
<li><strong>接收数据包</strong>：交换机从某个端口接收数据包，交换机会检查数据包的头部信息（包括源MAC和IP地址、目的MAC和IP地址）。同时将源MAC地址和其端口号记录到MAC地址表中</li>
<li><strong>查看MAC地址表</strong><ul>
<li><strong>找到目的MAC</strong> -&gt; 交换机对数据包进行端口<strong>转发</strong></li>
<li><strong>未找到目的MAC</strong> -&gt; 交换机会<strong>泛洪</strong>数据包，所有主机均会收到该数据包（除了接收端口）</li>
</ul>
</li>
<li><strong>更新MAC地址表</strong><ul>
<li><strong>收到响应数据包</strong> -&gt; 交换机记录响应数据包的源MAC地址和端口号，并更新MAC地址表</li>
<li><strong>未收到响应数据包</strong> -&gt; 说明目的主机可能不在网络中或者没有响应，数据包<strong>丢弃</strong>（交换机默认行为）</li>
</ul>
</li>
</ol>
<h3 id="三层交换机"><a href="#三层交换机" class="headerlink" title="三层交换机"></a><strong>三层交换机</strong></h3><p>三层交换机（L3 Switch）可以处理网络层协议，通过对缺省网关的查询学习来建立局域网（如企业内网、校园网）不同网段的直接连接。</p>
<p><strong>首次路由与后续转发</strong></p>
<ol>
<li>当主机A与不同子网的主机B通信时，三层交换机需要通过缺省网关进行路由决策：<ul>
<li>主机A发送ARP请求到缺省网关（三层交换机的IP）。</li>
<li>交换机查询路由表找到目标网段的下一跳地址，并通过ARP广播获取主机B的MAC地址。</li>
</ul>
</li>
<li>交换机将IP地址与MAC地址的映射记录到转发表（如FIB表和邻接表），并更新二层MAC地址表。</li>
<li>当数据包再次到达交换机后，直接通过二层转发（MAC地址表），无需重复路由，再次拆包分析IP地址（即“直接连接”）。</li>
</ol>
<h2 id="网卡Bond"><a href="#网卡Bond" class="headerlink" title="网卡Bond"></a>网卡Bond</h2><p>所谓bond，就是把多个物理网卡绑定成一个逻辑上的网卡，使用同一个IP工作，有时服务器带宽不够了也可以用作增加带宽。</p>
<p>借助于网卡bond技术，不仅可以提高网络传输速度，更重要的是，还可以确保在其中一块网卡出现故障时，依然可以正常提供网络服务。</p>
<p>网卡绑定mode共有七种(0~6) bond0、bond1、bond2、bond3、bond4、bond5、bond6。常用的有三种：</p>
<ul>
<li>mode&#x3D;0（平衡负载模式）：平时两块网卡均工作，且自动备援，但需要在与服务器本地网卡相连的交换机设备上进行端口聚合来支持绑定技术。</li>
<li>mode&#x3D;1（自动备援模式）：平时只有一块主网卡工作，在它故障后自动替换为另外的网卡。</li>
<li>mode&#x3D;6（平衡负载模式）：平时两块网卡均工作，且自动备援，无须交换机设备提供辅助支持。</li>
</ul>
<p><strong>1.Bond准备工作</strong></p>
<p>首先要确定服务器上的网卡规划用途，以及哪些网卡已插网线，一般是有两块网卡对应两根网线，分别连接不同的交换机。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 network-scripts]# ethtool p4p2</span><br><span class="line">Settings <span class="keyword">for</span> p4p2:</span><br><span class="line">        Supported ports: [ FIBRE ]</span><br><span class="line">        Supported <span class="built_in">link</span> modes:   1000baseKX/Full</span><br><span class="line">                                10000baseKR/Full</span><br><span class="line">                                25000baseCR/Full</span><br><span class="line">                                25000baseKR/Full</span><br><span class="line">                                25000baseSR/Full</span><br><span class="line">        Supported pause frame use: Symmetric</span><br><span class="line">        Supports auto-negotiation: Yes</span><br><span class="line">        Supported FEC modes: None BaseR</span><br><span class="line">        Advertised <span class="built_in">link</span> modes:  1000baseKX/Full</span><br><span class="line">                                10000baseKR/Full</span><br><span class="line">                                25000baseCR/Full</span><br><span class="line">                                25000baseKR/Full</span><br><span class="line">                                25000baseSR/Full</span><br><span class="line">        Advertised pause frame use: Symmetric</span><br><span class="line">        Advertised auto-negotiation: Yes</span><br><span class="line">        Advertised FEC modes: None</span><br><span class="line">        Speed: 10000Mb/s</span><br><span class="line">        Duplex: Full</span><br><span class="line">        Port: FIBRE</span><br><span class="line">        PHYAD: 0</span><br><span class="line">        Transceiver: internal</span><br><span class="line">        Auto-negotiation: on</span><br><span class="line">        Supports Wake-on: d</span><br><span class="line">        Wake-on: d</span><br><span class="line">        Current message level: 0x00000004 (4)</span><br><span class="line">                               <span class="built_in">link</span></span><br><span class="line">        Link detected: <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>ethtool查看网卡信息，<code>Link detected：yes</code>表示有网线插入；</p>
<p>如果<code>Link detected:no</code> 的话，尝试用<code>ifup ethxxx</code>，如果依然为no的话，才能说明此网卡确实没有网线插入。</p>
</blockquote>
<p><strong>2.网卡Bond配置</strong></p>
<p>方法一：命令行配置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为 storagepub 的网卡绑定接口，类型为 bond，模式为 802.3ad</span></span><br><span class="line">ip <span class="built_in">link</span> add storagepub <span class="built_in">type</span> bond mode 802.3ad xmit_hash_policy layer3+4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭网卡</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> ens4np1 down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将网卡 ens4np1 加入到名为 storagepub 的绑定接口，成为其从属（slave）设备</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> ens4np1 master storagepub</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用网卡</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> ens4np1 up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用绑定接口 storagepub，使其可用</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> storagepub up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看绑定接口 storagepub 的详细信息，包括模式、成员网卡、负载均衡策略等。</span></span><br><span class="line"><span class="built_in">cat</span> /proc/net/bonding/storagepub</span><br></pre></td></tr></table></figure>

<p>方法二：修改bond网卡的配置文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 network-scripts]# <span class="built_in">cat</span> ifcfg-bond-storagepub</span><br><span class="line">DEVICE=storagepub</span><br><span class="line">BONDING_OPTS=<span class="string">&quot;mode=4 miimon=100 xmit_hash_policy=1&quot;</span></span><br><span class="line">TYPE=Bond</span><br><span class="line">BONDING_MASTER=<span class="built_in">yes</span>	<span class="comment"># 表示该设备是绑定主设备（master）。</span></span><br><span class="line">BOOTPROTO=static	<span class="comment"># 使用静态 IP 配置（不依赖 DHCP）</span></span><br><span class="line">PEERDNS=no</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=no	<span class="comment"># 不启用 IPv6 配置</span></span><br><span class="line">NAME=bond-storagepub</span><br><span class="line">ONBOOT=<span class="built_in">yes</span></span><br><span class="line">IPADDR=172.22.88.177</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line"></span><br><span class="line">[root@master01 network-scripts]# <span class="built_in">cat</span> ifcfg-p4p2</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEVICE=p4p2</span><br><span class="line">ONBOOT=<span class="built_in">yes</span></span><br><span class="line">MASTER=storagepub	<span class="comment"># 指定绑定接口的主设备为 storagepu。</span></span><br><span class="line">SLAVE=<span class="built_in">yes</span>	<span class="comment"># 指定该网卡是绑定接口的从设备（slave）</span></span><br></pre></td></tr></table></figure>

<p>3.<strong>重启网络验证</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]# systemctl restart network</span><br><span class="line"></span><br><span class="line">[root@master01 ~]# ip a |grep storagepub</span><br><span class="line">11: p4p2: &lt;BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP&gt; mtu 1500 qdisc mq master storagepub state UP group default qlen 1000</span><br><span class="line">19: storagepub: &lt;BROADCAST,MULTICAST,MASTER,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    inet 172.22.88.177/24 brd 172.22.88.255 scope global noprefixroute storagepub</span><br></pre></td></tr></table></figure>

<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="交换机的VLAN怎么划分的"><a href="#交换机的VLAN怎么划分的" class="headerlink" title="交换机的VLAN怎么划分的"></a>交换机的VLAN怎么划分的</h2><p>为了解决广播域带来的问题，引入了VLAN (Virtual Local Area Network)，即虚拟局域网技术：</p>
<p>通过在交换机上部署VLAN，可以将一个规模较大的广播域在逻辑上划分成若干个规模较小的广播域，由此可以有效地提升网络的安全性，同时减少垃圾流量，节约网络资源。</p>
<p>每个VLAN网络（子网）是一个独立的广播域，VLAN内的设备可以相互通信，而不同VLAN之间的设备默认不能直接通信，必须通过三层设备（如路由器或三层交换机）进行路由才能互通。</p>
<p>划分VLAN的方法有多种，常见的包括：</p>
<ul>
<li><strong>基于端口划分（常用）</strong>：将交换机的端口分配到不同的VLAN中。例如，将端口1和2分配到VLAN10，端口3和4分配到VLAN20。</li>
<li><strong>基于MAC地址划分</strong>：根据设备的MAC地址将设备分配到不同的VLAN中。</li>
<li><strong>基于IP子网划分</strong>：根据设备的IP地址和子网掩码来划分VLAN。</li>
<li><strong>基于协议划分</strong>：根据设备使用的协议类型来划分VLAN。</li>
</ul>
<h2 id="不同网段如何实现通信"><a href="#不同网段如何实现通信" class="headerlink" title="不同网段如何实现通信"></a>不同网段如何实现通信</h2><p>不同网段的设备需要通过 <strong>路由设备</strong> 实现通信，具体流程如下：</p>
<ol>
<li>主机A（192.168.1.10）向主机B（192.168.2.20）发送数据包：<ul>
<li>主机A发现目标IP不在同一网段，因此将数据包的目标MAC地址设为 <strong>默认网关</strong>（如L3交换机的IP 192.168.1.1）。</li>
</ul>
</li>
<li>三层交换机接收数据包：<ul>
<li>根据目标IP 192.168.2.20 查询路由表，找到下一跳接口（如连接192.168.2.0网段的端口）。</li>
<li>发送 <strong>ARP请求</strong> 到目标网段，获取主机B的MAC地址。</li>
</ul>
</li>
<li>转发数据包：<ul>
<li>L3交换机将数据包的目标MAC改为主机B的MAC，源MAC改为自己的接口MAC，然后通过二层转发到目标网段。</li>
</ul>
</li>
<li>后续通信优化：<ul>
<li>三层交换机会缓存 IP-MAC映射 和 路由路径，后续数据包直接通过二层转发，无需重复路由。</li>
</ul>
</li>
</ol>
<h2 id="路由器和交换机区别"><a href="#路由器和交换机区别" class="headerlink" title="路由器和交换机区别"></a>路由器和交换机区别</h2><ol>
<li>交换机一般工作在数据链路层，而路由器则工作在网络层。</li>
<li>路由器可连接超过两个以上不同的网络，而交換机只能连接两个。</li>
<li>交换机是根据MAC地址转发数据帧，而路由器则是根据IP地址来转发IP数据包&#x2F;分组。</li>
<li>交换机主要是用于组建局域网，而路由器则更多用于广域网（WAN）或异构网络互联。</li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络设备</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx实战笔记：常用功能</title>
    <url>/2019/01/10/nginx_basic/</url>
    <content><![CDATA[<h1 id="Nginx常用功能"><a href="#Nginx常用功能" class="headerlink" title="Nginx常用功能"></a>Nginx常用功能</h1><h2 id="http正向代理"><a href="#http正向代理" class="headerlink" title="http正向代理"></a>http正向代理</h2><p>正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。<br>当然前提是客户端要知道正向代理服务器的 IP 地址，还有代理程序的端口。</p>
<p>正向代理的用途：<br>（1）访问原来无法访问的资源，如google<br>（2） 可以做缓存，加速访问资源<br>（3）对客户端访问授权，上网进行认证<br>（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</p>
<img src="/2019/01/10/nginx_basic/nginx1.png" class="" title="1.png">

<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。<br>反向代理的作用：<br>（1）保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击<br>（2）负载均衡，通过反向代理服务器来优化网站的负载</p>
<img src="/2019/01/10/nginx_basic/nginx2.png" class="" title="2.png">
<p>两者区别，看图说话：</p>
<img src="/2019/01/10/nginx_basic/nginx3.png" class="" title="3.png">

<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><p>这里提到的客户端发送的、Nginx 反向代理服务器接收到的请求数量，就是我们说的负载量。<br>请求数量按照一定的规则进行分发，到不同的服务器处理的规则，就是一种均衡规则。<br>所以将服务器接收到的请求按照规则分发的过程，称为负载均衡。</p>
<h3 id="nginx负载均衡算法"><a href="#nginx负载均衡算法" class="headerlink" title="nginx负载均衡算法"></a>nginx负载均衡算法</h3><p>Nginx提供的负载均衡策略有2种：内置策略和扩展策略。内置策略为轮询，加权轮询，Ip hash。<br>扩展策略，就天马行空，只有你想不到的没有他做不到的啦，你可以参照所有的负载均衡算法，给他一一找出来做下实现。<br>上2个图，理解这三种负载均衡算法的实现</p>
<img src="/2019/01/10/nginx_basic/nginx4.png" class="" title="4.png">

<img src="/2019/01/10/nginx_basic/nginx5.png" class="" title="5.png">
<p>Ip hash算法，对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。</p>
<h1 id="Nginx配置文件详解"><a href="#Nginx配置文件详解" class="headerlink" title="Nginx配置文件详解"></a>Nginx配置文件详解</h1><p>Nginx配置文件主要分成四部分：main（全局设置）、server（主机设置）、upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）和location（URL匹配特定位置后的设置），每部分包含若干个指令。</p>
<p>他们之间的关系式：server继承main，location继承server；upstream既不会继承指令也不会被继承。它有自己的特殊指令，不需要在其他地方的应用</p>
<p>main部分设置的指令将影响其它所有部分的设置；server部分的指令主要用于指定虚拟主机域名、IP和端口；upstream的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；location部分用于匹配网页位置（比如，根目录”&#x2F;“,”&#x2F;images”,等等）。</p>
<blockquote>
<p>docker run –name nginx-test -p 8080:80 -d nginx<br>使用docker命令直接安装启动nginx</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入容器内查看默认的配置文件,均在/etc/nginx/路径下。</span></span><br><span class="line">localhost:~ liaoxb$ docker <span class="built_in">exec</span> -ti 2ccbf7fa358e sh</span><br><span class="line"><span class="comment"># find / -name nginx.conf</span></span><br><span class="line">/etc/nginx/nginx.conf</span><br><span class="line"><span class="comment"># find / -name default.conf</span></span><br><span class="line">/etc/nginx/conf.d/default.conf</span><br></pre></td></tr></table></figure>

<p>默认的 nginx 配置文件 nginx.conf 内容如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">root@2ccbf7fa358e:/<span class="comment"># cat /etc/nginx/nginx.conf</span></span><br><span class="line"><span class="attribute">user</span>  nginx;    <span class="comment">#定义Nginx运行的用户和用户组</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;    <span class="comment">#nginx进程数，建议设置为等于CPU总核心数</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/<span class="literal">error</span>.log <span class="literal">warn</span>;   <span class="comment">#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;  <span class="comment">#进程pid文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;       <span class="comment">#单个进程最大连接数（最大连接数=连接数*进程数）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;        <span class="comment">#文件扩展名与文件类型映射表</span></span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;     <span class="comment">#默认文件类型</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line">    </span><br><span class="line"><span class="comment">#开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line"><span class="comment">#此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用</span></span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;      <span class="comment">#长连接超时时间，单位是秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;      #gzip模块设置</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;   <span class="comment">#增加nginx虚拟主机配置文件(conf.d)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>默认的nginx虚拟主机配置文件如下（反向代理到nginx的默认html页面，位于&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html）：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">root@2ccbf7fa358e:/<span class="comment"># cat /etc/nginx/conf.d/default.conf</span></span><br><span class="line"><span class="comment">#虚拟主机的配置</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;    <span class="comment">#监听端口</span></span><br><span class="line">    <span class="attribute">server_name</span>  localhost;     <span class="comment">#域名可以有多个，用空格隔开</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"><span class="comment">#对 &quot;/&quot; 启用反向代理</span></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;   <span class="comment">#根目录</span></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;    <span class="comment">#设置默认页</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    root           html;</span></span><br><span class="line">    <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">    <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">    <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">    <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class="line">    <span class="comment"># concurs with nginx&#x27;s one</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">    <span class="comment">#    deny  all;     #拒绝的ip</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考文档：<br><a href="https://www.runoob.com/w3cnote/nginx-setup-intro.html">https://www.runoob.com/w3cnote/nginx-setup-intro.html</a><br><a href="https://www.runoob.com/w3cnote/nginx-setup-intro.html">https://www.runoob.com/w3cnote/nginx-setup-intro.html</a><br><a href="https://www.w3cschool.cn/nginx/nginx-d1aw28wa.html">https://www.w3cschool.cn/nginx/nginx-d1aw28wa.html</a></p>
]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>NFS服务器搭建和挂载</title>
    <url>/2018/05/26/nfs_server_install/</url>
    <content><![CDATA[<h1 id="nfs-server-install"><a href="#nfs-server-install" class="headerlink" title="nfs-server-install"></a>nfs-server-install</h1><p>NFS 是Network File System的缩写，即网络文件系统。功能是通过网络让不同的机器、不同的操作系统能够彼此分享个别的数据，让应用程序在客户端通过网络访问位于服务器磁盘中的数据，是在类Unix系统间实现磁盘文件共享的一种方法。<br>NFS在文件传送或信息传送过程中依赖于RPC协议。所以只要用到NFS的地方都要启动RPC服务，不论是NFS SERVER或者NFS CLIENT。这样SERVER和CLIENT才能通过RPC来实现PROGRAM PORT（centos5之前，之后是rpcbind）的对应。可以这么理解RPC和NFS的关系：NFS是一个文件系统，而RPC是负责信息的传输。</p>
<p>Centos系统环境：<br>服务端IP 192.168.1.28<br>客户端IP 192.168.1.21、192.168.1.155</p>
<p>一、安装NFS-Server</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rpm -qa|grep nfs <span class="comment">#检查系统是否已安装NFS</span></span><br><span class="line">yum install nfs-utils -y <span class="comment">#客户端和服务端都要安装</span></span><br></pre></td></tr></table></figure>

<img src="/2018/05/26/nfs_server_install/nfs01.png" class="" title="image">

<p>二、服务端配置启动NFS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /var/nfsshare </span><br><span class="line">vim /etc/exports #配置共享目录供客户端集群以读写权限访问</span><br><span class="line">systemctl start nfs</span><br><span class="line">showmount -e localhost //查询NFS的共享状态</span><br><span class="line"></span><br><span class="line">[root@test--0004 ~]# showmount -e 192.168.1.28</span><br><span class="line">Export list for 192.168.1.28:</span><br><span class="line">/var/nfsshare2 *</span><br><span class="line">/var/nfsshare *</span><br></pre></td></tr></table></figure>



<p>说明：NFS服务的配置文件为&#x2F;etc&#x2F;exports，这个文件是NFS的主要配置文件，不过系统并没有默认值，所以这个文件不一定会存在，可能要使用vim手动建立，然后在文件里面写入配置内容。内容格式如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;输出目录&gt; [客户端1 选项（访问权限,用户映射,其他）] [客户端2 选项（访问权限,用户映射,其他)]</span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">1、输出目录：输出目录是指NFS系统中需要共享给客户机使用的目录；</span><br><span class="line">2、客户端：客户端是指网络中可以访问这个NFS输出目录的计算机</span><br><span class="line">          客户端常用的指定方式：</span><br><span class="line">          指定ip地址的主机：192.168.8.106</span><br><span class="line">          指定子网中的所有主机：192.168.0.0/24或 192.168.0.0/255.255.255.0</span><br><span class="line">          指定域名的主机：wj.bsmart.com</span><br><span class="line">          指定域中的所有主机：*.bsmart.com</span><br><span class="line">          所有主机：*</span><br><span class="line"></span><br><span class="line">3、 选项：选项用来设置输出目录的访问权限、用户映射等。</span><br><span class="line"></span><br><span class="line">   NFS主要有3类选项：</span><br><span class="line"></span><br><span class="line">  1）访问权限选项：</span><br><span class="line"></span><br><span class="line">          设置输出目录只读：ro</span><br><span class="line">          设置输出目录读写：rw</span><br><span class="line">          </span><br><span class="line">2）用户映射选项</span><br><span class="line"></span><br><span class="line">    all_squash：将远程访问的所有普通用户及所属组都映射为匿名用户或用户组（nfsnobody）；</span><br><span class="line">    no_all_squash：与all_squash取反（默认设置）；</span><br><span class="line">    root_squash：将root用户及所属组都映射为匿名用户或用户组（默认设置）；</span><br><span class="line">    no_root_squash：与rootsquash取反；</span><br><span class="line">    anonuid=xxx：将远程访问的所有用户都映射为匿名用户，并指定该用户为本地用户（UID=xxx）；</span><br><span class="line">    anongid=xxx：将远程访问的所有用户组都映射为匿名用户组账户，并指定该匿名用户组账户为本地用户组账户（GID=xxx）；</span><br><span class="line"></span><br><span class="line">3）其它选项</span><br><span class="line"></span><br><span class="line">    secure：限制客户端只能从小于1024的tcp/ip端口连接nfs服务器（默认设置）；</span><br><span class="line">    insecure：允许客户端从大于1024的tcp/ip端口连接服务器；</span><br><span class="line">    <span class="built_in">sync</span>：将数据同步写入内存缓冲区与磁盘中，效率低，但可以保证数据的一致性；</span><br><span class="line">    async：将数据先保存在内存缓冲区中，必要时才写入磁盘；</span><br><span class="line">    wdelay：检查是否有相关的写操作，如果有则将这些写操作一起执行，这样可以提高效率（默认设置）；</span><br><span class="line">    no_wdelay：若有写操作则立即执行，应与<span class="built_in">sync</span>配合使用；</span><br><span class="line">    subtree：若输出目录是一个子目录，则nfs服务器将检查其父目录的权限(默认设置)；</span><br><span class="line">    no_subtree：即使输出目录是一个子目录，nfs服务器也不检查其父目录的权限，这样可以提高效率；</span><br></pre></td></tr></table></figure>

<p>三、设置开机启动</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> rpcbind.service</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs-service</span><br></pre></td></tr></table></figure>



<p>四、测试挂载：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">客户端执行：</span><br><span class="line">mount -t nfs 192.168.1.28:/var/nfsshare /mnt <span class="comment">#客户端挂载NFS服务器中的共享目录</span></span><br><span class="line"><span class="built_in">touch</span> /mnt/test.txt <span class="comment">#客户端挂载点生成文件，此文件会被共享至NFS服务器:/var/nfsshare</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello word&quot;</span> &gt; /mnt/test.txt</span><br><span class="line">umount /mnt <span class="comment">#解除和NFS服务器的挂载</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
      <tags>
        <tag>NFS</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx实战笔记：配置反向代理访问监控系统</title>
    <url>/2019/01/24/nginx_proxy/</url>
    <content><![CDATA[<h1 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h1><p>1、测试环境部署了一套监控系统，测试人员经常需要访问web去分析数据或定位问题，但是访问不方便也不灵活,每次需要去找到pod运行主机IP和svc暴露的端口。<br>2、通过利用nginx反向代理+负载均衡配置，快速地访问系统。比如prometheus、granfana等</p>
<h1 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h1><p>1、查看测试集群监控服务的pod和svc信息，prometheus和grafana均以NodePort的形式映射到主机端口。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">|kubernetes-admin@q4-default# kcc get po,svc |grep grafana</span><br><span class="line">pod/grafana-6c5f687b5b-79qf8                         1/1       Running     0          56m</span><br><span class="line"></span><br><span class="line">service/grafana                         NodePort    10.104.106.121   &lt;none&gt;        3000:31962/TCP      12d</span><br><span class="line">|kubernetes-admin@q4-default# kca get po,svc |grep prometheus</span><br><span class="line">pod/prometheus-68d7459bb-cmnmn                  5/5       Running   0          2d</span><br><span class="line"></span><br><span class="line">service/prometheus                 NodePort    10.99.169.156   &lt;none&gt;        81:32001/TCP,9093:32003/TCP   2d</span><br></pre></td></tr></table></figure>



<p>这时是可以通过集群内主机内网ip+端口，成功访问到监控系统。比如访问prometheus端口32001</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@harbor nginx-proxy]# curl 192.168.0.34:32001</span><br><span class="line">&lt;a href=<span class="string">&quot;/graph&quot;</span>&gt;Found&lt;/a&gt;.</span><br><span class="line"></span><br><span class="line">[root@harbor nginx-proxy]# curl 192.168.0.35:32001</span><br><span class="line">&lt;a href=<span class="string">&quot;/graph&quot;</span>&gt;Found&lt;/a&gt;.</span><br><span class="line"></span><br><span class="line">[root@harbor nginx-proxy]# curl 192.168.0.36:32001</span><br><span class="line">&lt;a href=<span class="string">&quot;/graph&quot;</span>&gt;Found&lt;/a&gt;.</span><br></pre></td></tr></table></figure>



<p>2、nginx配置文件如下</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">[root@<span class="attribute">harbor</span> nginx-proxy]<span class="comment"># cat default.conf</span></span><br><span class="line">    <span class="comment"># 设定实际的后端服务器列表</span></span><br><span class="line">    upstream prometheus_server&#123;</span><br><span class="line">	    <span class="comment">#设定负载均衡的服务器列表，weigth参数表示权值（缺省是1），权值越高被分配到的几率越大</span></span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.0.34:32001</span> weight=<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.0.35:32001</span> weight=<span class="number">2</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.0.36:32001</span> weight=<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">upstream</span> alert_server&#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.0.34:32003</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.0.35:32003</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.0.36:32003</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">upstream</span> grafana_server&#123;</span><br><span class="line">        <span class="attribute">server</span>  <span class="number">192.168.0.34:31962</span>;</span><br><span class="line">        <span class="comment">#server 192.168.0.35:31962;</span></span><br><span class="line">        <span class="comment">#server 192.168.0.36:31962;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment">#监听80端口，用于HTTP协议</span></span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="comment">#定义使用www.test.com访问</span></span><br><span class="line">        <span class="attribute">server_name</span>  www.test.com;</span><br><span class="line">        <span class="attribute">proxy_headers_hash_max_size</span>     <span class="number">51200</span>;</span><br><span class="line">        <span class="attribute">proxy_headers_hash_bucket_size</span>  <span class="number">6400</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>                Host             <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>                X-Real-IP        <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>                X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#location / &#123;</span></span><br><span class="line">        <span class="comment">#    root /usr/share/nginx/html;</span></span><br><span class="line">        <span class="comment">#    index index.html;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">        <span class="comment">#反向代理的路径</span></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="comment">#请求将转向upstream里prometheus_server定义的服务器列表</span></span><br><span class="line">            <span class="attribute">proxy_pass</span>  http://prometheus_server/;</span><br><span class="line">            <span class="comment">#nginx跟后端服务器连接超时时间(代理连接超时)</span></span><br><span class="line">            <span class="attribute">proxy_connect_timeout</span>     <span class="number">30s</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="section">location</span> /alert/ &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span>  http://alert_server/;</span><br><span class="line">            <span class="attribute">proxy_connect_timeout</span>     <span class="number">30s</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="section">location</span> /grafana/ &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span>  http://grafana_server/;</span><br><span class="line">            <span class="attribute">proxy_connect_timeout</span>     <span class="number">30s</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>3、make run快速启动nginx容器<br>Makefile里总共三步操作：<br>快速启动nginx容器，映射到主机端口8081，<br>拷贝default.conf到nginx容器&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;目录<br>重启nginx容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@harbor nginx-proxy]# ll</span><br><span class="line">总用量 12</span><br><span class="line">-rw-r--r-- 1 root root 1587 1月  24 21:39 default_backup.conf</span><br><span class="line">-rw-r--r-- 1 root root 1327 1月  24 21:40 default.conf</span><br><span class="line">-rw-r--r-- 1 root root  353 1月  24 21:44 Makefile</span><br><span class="line">[root@harbor nginx-proxy]# make run</span><br><span class="line">docker <span class="built_in">rm</span> -f nginx-web</span><br><span class="line">nginx-web</span><br><span class="line">docker run -d -p 8081:80 --name nginx-web nginx</span><br><span class="line">229484284a78d84800527337eb7a074d42ff62987cb8e479a0d6c4c65b586156</span><br><span class="line">docker <span class="built_in">cp</span> default.conf nginx-web:/etc/nginx/conf.d/</span><br><span class="line">docker restart nginx-web</span><br><span class="line">nginx-web</span><br><span class="line">[root@harbor nginx-proxy]# docker ps |grep nginx-web</span><br><span class="line">229484284a78        nginx                                                                 <span class="string">&quot;nginx -g &#x27;daemon ...&quot;</span>   30 seconds ago      Up 29 seconds          0.0.0.0:8081-&gt;80/tcp                                               nginx-web</span><br></pre></td></tr></table></figure>

<p>4、在浏览器中访问 <a href="http://www.test.com,这时应该就可以根据location,访问到不同的服务了./">www.test.com，这时应该就可以根据location，访问到不同的服务了。</a><br>访问Grafana Dashboard：</p>
<img src="/2019/01/24/nginx_proxy/nginx15.png" class="" title="7.png">
<p>访问Alertmanager ui：</p>
<img src="/2019/01/24/nginx_proxy/nginx16.png" class="" title="7.png">
<p>访问:Prometheus ui</p>
<img src="/2019/01/24/nginx_proxy/nginx17.png" class="" title="7.png">

<h1 id="关于负载均衡策略"><a href="#关于负载均衡策略" class="headerlink" title="关于负载均衡策略"></a>关于负载均衡策略</h1><p>Nginx提供了多种负载均衡策略，在上面其实已用到过轮询算法。在这里延伸多了解一下其它策略。</p>
<h2 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> bck_testing_01 &#123;</span><br><span class="line">  <span class="comment"># 默认所有服务器权重为 1</span></span><br><span class="line">  <span class="attribute">server</span> <span class="number">192.168.250.220:8080</span></span><br><span class="line">  server <span class="number">192.168.250.221:8080</span></span><br><span class="line">  server <span class="number">192.168.250.222:8080</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="加权轮询"><a href="#加权轮询" class="headerlink" title="加权轮询"></a>加权轮询</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> bck_testing_01 &#123;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">192.168.250.220:8080</span>  weight=<span class="number">3</span></span><br><span class="line">  server <span class="number">192.168.250.221:8080</span></span><br><span class="line">  server <span class="number">192.168.250.222:8080</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最少连接"><a href="#最少连接" class="headerlink" title="最少连接"></a>最少连接</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> bck_testing_01 &#123;</span><br><span class="line">  least_conn;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">192.168.250.220:8080</span></span><br><span class="line">  server <span class="number">192.168.250.221:8080</span></span><br><span class="line">  server <span class="number">192.168.250.222:8080</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IP-Hash"><a href="#IP-Hash" class="headerlink" title="IP Hash"></a>IP Hash</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> bck_testing_01 &#123;</span><br><span class="line">  ip_hash;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">192.168.250.220:8080</span></span><br><span class="line">  server <span class="number">192.168.250.221:8080</span></span><br><span class="line">  server <span class="number">192.168.250.222:8080</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考文档：<br><a href="https://www.w3cschool.cn/nginx/nginx-d1aw28wa.html">https://www.w3cschool.cn/nginx/nginx-d1aw28wa.html</a><br><a href="https://mp.weixin.qq.com/s/qMtJtZ6g62wibRVilIHPNg">https://mp.weixin.qq.com/s/qMtJtZ6g62wibRVilIHPNg</a></p>
]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx实战笔记：搭建静态文件服务器</title>
    <url>/2019/01/17/nginx_web/</url>
    <content><![CDATA[<p>上次了解到nginx相关基础知识，这次就趁热打铁，学习亲手搭建一个静态资源的文件服务器。其中会涉及到gzip功能的配置。</p>
<h1 id="搭建目标"><a href="#搭建目标" class="headerlink" title="搭建目标"></a>搭建目标</h1><p>1、可以成功访问一些静态资源文件（图片、日志文件html等）<br>2、服务器会以gzip压缩的形式返回数据</p>
<h1 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h1><h2 id="容器运行nginx，端口映射到本机8080"><a href="#容器运行nginx，端口映射到本机8080" class="headerlink" title="容器运行nginx，端口映射到本机8080"></a>容器运行nginx，端口映射到本机8080</h2><img src="/2019/01/17/nginx_web/nginx6.jpeg" class="" title="6.png">

<h2 id="查看静态资源文件和nginx-conf"><a href="#查看静态资源文件和nginx-conf" class="headerlink" title="查看静态资源文件和nginx.conf"></a>查看静态资源文件和nginx.conf</h2><p>本地机器上，静态资源全部放在static-web目录下。<br>子目录img存放的是图片jpg、png，子目录robot-log存放的是每天归档的测试日志报告html。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">localhost:nginx-test liaoxb$ tree</span><br><span class="line">.</span><br><span class="line">├── nginx.conf</span><br><span class="line">└── static-web</span><br><span class="line">    ├── img</span><br><span class="line">    │   ├── test01.jpg</span><br><span class="line">    │   └── test02.png</span><br><span class="line">    └── robot-log</span><br><span class="line">        ├── 2019-01-16</span><br><span class="line">        │   ├── log.html</span><br><span class="line">        │   ├── output.xml</span><br><span class="line">        │   └── report.html</span><br><span class="line">        └── 2019-01-17</span><br><span class="line">            ├── log.html</span><br><span class="line">            ├── output.xml</span><br><span class="line">            └── report.html</span><br></pre></td></tr></table></figure>



<p>相比nginx容器内的默认配置文件，本地对nginx.conf做了如下改动(重要)：<br>1、开启了gzip功能，并配置了相关参数（后面会详细介绍参数）<br>2、server块里追加了两个location块（&#x2F;img&#x2F;、&#x2F;robot-log&#x2F;），将对应请求路由到root所指向的目录或index文件<br>3、修改了server_name，记得在本地主机&#x2F;etc&#x2F;hosts文件下写入static.web.com<br>4、注释了include参数，不过根目录依然是可以访问到nginx默认欢迎页面的。</p>
<p>完整配置内容如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/<span class="literal">error</span>.log <span class="literal">warn</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">gzip</span>              <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">gzip_min_length</span>   <span class="number">1k</span>;</span><br><span class="line">    <span class="attribute">gzip_buffers</span>      <span class="number">4</span> <span class="number">16k</span>;</span><br><span class="line">    <span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">gzip_comp_level</span>   <span class="number">3</span>;</span><br><span class="line">    <span class="attribute">gzip_types</span>        text/plain application/x-javascript text/css application/xml text/javascript application/javascript image/jpeg image/jpg image/png;</span><br><span class="line">    <span class="attribute">gzip_proxied</span>      any;</span><br><span class="line">    <span class="attribute">gzip_vary</span>         <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">gzip_disable</span>      <span class="string">&quot;MSIE [1-6]\.&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  static.web.com;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">            <span class="attribute">index</span> index.html;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="section">location</span> /img/ &#123;</span><br><span class="line">            <span class="attribute">root</span> /usr/share/static-web;</span><br><span class="line">            <span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="section">location</span> /robot-log/ &#123;</span><br><span class="line">            <span class="attribute">root</span> /usr/share/static-web;</span><br><span class="line">            <span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#include /etc/nginx/conf.d/*.conf;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态配置nginx容器"><a href="#动态配置nginx容器" class="headerlink" title="动态配置nginx容器"></a>动态配置nginx容器</h2><p>动态配置nginx容器，需执行以下三步操作：<br>1、替换容器内的&#x2F;etc&#x2F;nginx&#x2F;nginx.conf<br>2、拷贝静态资源目录static-web到指定的容器目录&#x2F;usr&#x2F;share&#x2F;<br>3、重启nginx容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">localhost:nginx-test liaoxb$ ll</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x   4 liaoxb  staff   128  3  2 22:56 ./</span><br><span class="line">drwxr-xr-x  10 liaoxb  staff   320  3  1 23:28 ../</span><br><span class="line">-rw-r--r--@  1 liaoxb  staff  1404  1 16  2019 nginx.conf</span><br><span class="line">drwxr-xr-x   5 liaoxb  staff   160  1 16  2019 static-web/</span><br><span class="line">localhost:nginx-test liaoxb$ docker <span class="built_in">cp</span> nginx.conf nginx-test:/etc/nginx/</span><br><span class="line">localhost:nginx-test liaoxb$ docker <span class="built_in">cp</span> static-web nginx-test:/usr/share/</span><br><span class="line">localhost:nginx-test liaoxb$ docker restart nginx-test</span><br><span class="line">nginx-test</span><br><span class="line">localhost:nginx-test liaoxb$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">addfae34988b        nginx               <span class="string">&quot;nginx -g &#x27;daemon of…&quot;</span>   About an hour ago   Up 7 seconds        0.0.0.0:8080-&gt;80/tcp   nginx-test</span><br></pre></td></tr></table></figure>

<h1 id="访问静态资源"><a href="#访问静态资源" class="headerlink" title="访问静态资源"></a>访问静态资源</h1><p>1、域名:8080访问根目录，成功访问nginx默认web页面</p>
<img src="/2019/01/17/nginx_web/nginx8.png" class="" title="8.png">
<p>2、域名:8080访问&#x2F;img&#x2F;，成功访问目录下的所有图片</p>
<img src="/2019/01/17/nginx_web/nginx9.png" class="" title="9.png">
<p>3、域名:8080访问&#x2F;robot-log&#x2F;，成功访问目录下的归档日志</p>
<img src="/2019/01/17/nginx_web/nginx10.png" class="" title="10.png">
<img src="/2019/01/17/nginx_web/nginx11.png" class="" title="11.png">

<h2 id="gzip配置详解"><a href="#gzip配置详解" class="headerlink" title="gzip配置详解"></a>gzip配置详解</h2><blockquote>
<p>Nginx实现资源压缩的原理是通过ngx_http_gzip_module模块拦截请求，并对需要做gzip的类型做gzip，ngx_http_gzip_module是Nginx默认集成的，不需要重新编译，直接开启即可。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启gzip</span></span><br><span class="line">gzip              on;</span><br><span class="line"><span class="comment"># 启用gzip压缩的最小文件，小于设置值的文件将不会压缩</span></span><br><span class="line">gzip_min_length   1k;</span><br><span class="line"><span class="comment"># 设置压缩所需要的缓冲区大小</span></span><br><span class="line">gzip_buffers      4 16k;</span><br><span class="line"><span class="comment"># 设置gzip压缩针对的HTTP协议版本</span></span><br><span class="line">gzip_http_version 1.1;</span><br><span class="line"><span class="comment"># gzip 压缩级别，1-9，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明</span></span><br><span class="line">gzip_comp_level   3;</span><br><span class="line"><span class="comment"># 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到</span></span><br><span class="line">gzip_types        text/plain application/x-javascript text/css application/xml text/javascript application/javascript image/jpeg image/jpg image/png;</span><br><span class="line">gzip_proxied      any;</span><br><span class="line"><span class="comment"># 是否在http header中添加Vary: Accept-Encoding，建议开启</span></span><br><span class="line">gzip_vary         on;</span><br><span class="line"><span class="comment"># 禁用IE 6 gzip</span></span><br><span class="line">gzip_disable      <span class="string">&quot;MSIE [1-6]\.&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="压缩效果对比"><a href="#压缩效果对比" class="headerlink" title="压缩效果对比"></a>压缩效果对比</h2><img src="/2019/01/17/nginx_web/nginx14.jpeg" class="" title="14.png">
<p>curl命令直接对比查看：</p>
<p>第一次curl请求头未带’Accept-Encoding: gzip,deflate’时，服务器不会压缩，直接返回html，从Content-Length也可以看出report.html的size是233340，也就是228kb大小。</p>
<p>第二次curl请求头带了’Accept-Encoding: gzip,deflate’时，服务器则会进行压缩数据后再返回content，同时response字段也会出现Content-Encoding: gzip，这就证明gzip压缩配置生效了。不过这次的response看不见Content-Length，怎么确定压缩成多少了呢？</p>
<p>这也很容易，结合着浏览器访问同个web页面查看size就清楚了，压缩后是77.1kb。</p>
<img src="/2019/01/17/nginx_web/nginx12.png" class="" title="12.png">

<p>参考文档：<br><a href="https://www.w3cschool.cn/nginx/nginx-d1aw28wa.html">https://www.w3cschool.cn/nginx/nginx-d1aw28wa.html</a></p>
]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Python面试问题汇总</title>
    <url>/2020/01/22/python-interview/</url>
    <content><![CDATA[<h1 id="Python-面试题"><a href="#Python-面试题" class="headerlink" title="Python 面试题"></a>Python 面试题</h1><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><h3 id="如何将字符串-“ilovechina”-进行反转"><a href="#如何将字符串-“ilovechina”-进行反转" class="headerlink" title="如何将字符串 “ilovechina” 进行反转"></a>如何将字符串 “ilovechina” 进行反转</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;ilovechina&#x27;</span></span><br><span class="line">s = s[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="如何将-“1-2-3”-分割成-“1”-”2”-”3”-？"><a href="#如何将-“1-2-3”-分割成-“1”-”2”-”3”-？" class="headerlink" title="如何将 “1,2,3” 分割成 [“1”,”2”,”3”]？"></a>如何将 “1,2,3” 分割成 [“1”,”2”,”3”]？</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;1,2,3&quot;</span></span><br><span class="line">stdout = s.split(<span class="string">&#x27;,&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Python-中的字符串格式化方式你知道哪些？"><a href="#Python-中的字符串格式化方式你知道哪些？" class="headerlink" title="Python 中的字符串格式化方式你知道哪些？"></a>Python 中的字符串格式化方式你知道哪些？</h3><p>Python3.6之后的版本提供了三种字符串格式化的方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. %s占位符</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name</span>):</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hello %s&#x27;</span> % name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. format() </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name</span>):</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hello &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.f-string</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name</span>):</span><br><span class="line">  <span class="keyword">return</span> <span class="string">f&#x27;hello <span class="subst">&#123;name&#125;</span>&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="列表元素怎么去重"><a href="#列表元素怎么去重" class="headerlink" title="列表元素怎么去重"></a>列表元素怎么去重</h3><p>自己动手写函数实现（保留原顺序）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">old_list = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">new_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> old_list:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> new_list:</span><br><span class="line">        new_list.append(i)</span><br><span class="line"><span class="built_in">print</span>(new_list) <span class="comment"># [2, 3, 4, 5, 1]</span></span><br></pre></td></tr></table></figure>

<p>用字典dict去重（保留原顺序）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用list元素值创建一个dict，这将自动删除任何重复项</span></span><br><span class="line">old_list = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">new_list = <span class="built_in">list</span>(<span class="built_in">dict</span>.fromkeys(old_list))</span><br><span class="line"><span class="built_in">print</span>(new_list) <span class="comment"># [2, 3, 4, 5, 1]</span></span><br></pre></td></tr></table></figure>

<p>使用sort函数来去重（保留原顺序）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst1 = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">lst2.sort(key=lst1.index)</span><br><span class="line"><span class="built_in">print</span>(lst2)    <span class="comment"># [2, 1, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>使用内置set方法（不保证原顺序）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将list转化为set再转化为list</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">list2 = <span class="built_in">list</span>(<span class="built_in">set</span>(list1))</span><br><span class="line"><span class="built_in">print</span>(list2)    <span class="comment"># &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="两个列表怎么转成字典"><a href="#两个列表怎么转成字典" class="headerlink" title="两个列表怎么转成字典"></a>两个列表怎么转成字典</h3><ul>
<li>动手写一个函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>]</span><br><span class="line">list2 = [<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>]</span><br><span class="line"><span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list1)):</span><br><span class="line">    <span class="built_in">dict</span>[list1[i]] = list2[i]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>, <span class="built_in">type</span>(<span class="built_in">dict</span>)) <span class="comment"># &#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: 18, &#x27;sex&#x27;: &#x27;男&#x27;&#125; &lt;class &#x27;dict&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用内置函数zip</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>]</span><br><span class="line">list2 = [<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>]</span><br><span class="line">d = <span class="built_in">dict</span>(<span class="built_in">zip</span>(list1, list2))</span><br><span class="line"><span class="built_in">print</span>(d)    <span class="comment"># &#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: 18, &#x27;sex&#x27;: &#x27;男&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="如何合并两个列表"><a href="#如何合并两个列表" class="headerlink" title="如何合并两个列表"></a>如何合并两个列表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">b = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法1</span></span><br><span class="line">a.extend(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2</span></span><br><span class="line">a[<span class="number">0</span>:<span class="number">0</span>] = b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法3</span></span><br><span class="line">a += b</span><br></pre></td></tr></table></figure>

<h3 id="举例-sort-和-sorted-的区别"><a href="#举例-sort-和-sorted-的区别" class="headerlink" title="举例 sort 和 sorted 的区别"></a>举例 sort 和 sorted 的区别</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sort()与sorted()的不同在于，sort是在原位重新排列列表，而sorted()是产生一个新的列表</span><br></pre></td></tr></table></figure>

<h3 id="如何把-元组-“a”-”b”-、-1-2-，变为字典-“a”-1-”b”-2-？"><a href="#如何把-元组-“a”-”b”-、-1-2-，变为字典-“a”-1-”b”-2-？" class="headerlink" title="如何把 元组 (“a”,”b”) 、(1,2)，变为字典{“a”:1,”b”:2}？"></a>如何把 元组 (“a”,”b”) 、(1,2)，变为字典{“a”:1,”b”:2}？</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">b = (<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">z = <span class="built_in">zip</span>(a,b)</span><br><span class="line">c = <span class="built_in">dict</span>(z)</span><br></pre></td></tr></table></figure>
<h3 id="字典操作中-del-和-pop-有什么区别？"><a href="#字典操作中-del-和-pop-有什么区别？" class="headerlink" title="字典操作中 del 和 pop 有什么区别？"></a>字典操作中 del 和 pop 有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">del 操作删除键值对，不返回值；</span><br><span class="line">pop 操作删除键值对的同时，返回键所对应的值。</span><br></pre></td></tr></table></figure>

<h3 id="如何合并两个字典"><a href="#如何合并两个字典" class="headerlink" title="如何合并两个字典"></a>如何合并两个字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python3合并字典有三种方式</span></span><br><span class="line"><span class="comment"># 1.</span></span><br><span class="line">a = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line">b = &#123;<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>,<span class="string">&#x27;d&#x27;</span>:<span class="number">4</span>&#125;</span><br><span class="line">c = &#123;&#125;</span><br><span class="line">c.update(a)</span><br><span class="line">c.update(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.</span></span><br><span class="line">c = <span class="built_in">dict</span>(a,**b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.动态解包</span></span><br><span class="line">c = &#123;**a,**b&#125; <span class="comment"># 官方推荐这种方式</span></span><br></pre></td></tr></table></figure>

<h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><h3 id="在读文件操作的时候会使用-read、readline-或者-readlines，简述它们各自的作用"><a href="#在读文件操作的时候会使用-read、readline-或者-readlines，简述它们各自的作用" class="headerlink" title="在读文件操作的时候会使用 read、readline 或者 readlines，简述它们各自的作用"></a>在读文件操作的时候会使用 read、readline 或者 readlines，简述它们各自的作用</h3><ul>
<li>read():一次读取文本全部内容为字符串（可以指定size去读取），占用空间大</li>
<li>readline():读取文本为一个生成器，支持遍历和迭代，占用空间小</li>
<li>readlines():一次读取文本全部内容为列表，占用空间大</li>
</ul>
<h3 id="Python-字典和-json-字符串相互转化方法"><a href="#Python-字典和-json-字符串相互转化方法" class="headerlink" title="Python 字典和 json 字符串相互转化方法"></a>Python 字典和 json 字符串相互转化方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">json.dumps()   将Python中的对象转换为JSON中的字符串对象</span><br><span class="line">json.loads()   将JSON中的字符串对象转换为Python中的对象</span><br></pre></td></tr></table></figure>

<h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><h3 id="Python-中的基本数据结构"><a href="#Python-中的基本数据结构" class="headerlink" title="Python 中的基本数据结构"></a>Python 中的基本数据结构</h3><blockquote>
<p>基本结构通常指列表、元组、字典、集合，而字符串可能作为序列类型单独列出</p>
</blockquote>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>特点</th>
<th>实现原理</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>列表</strong></td>
<td>有序、可变、允许重复元素</td>
<td>动态数组存储，支持自动扩容</td>
<td>动态数据读取&#x2F;更新、栈&#x2F;队列实现</td>
</tr>
<tr>
<td><strong>元组</strong></td>
<td>有序、不可变、允许重复元素</td>
<td>紧凑数组存储</td>
<td>存储固定数据（如函数参数传递、配置参数），比列表更节省内存</td>
</tr>
<tr>
<td><strong>字典</strong></td>
<td>无序（Python 3.7+ 有序）、可变、键值对</td>
<td>哈希表</td>
<td>快速查询、JSON 数据处理</td>
</tr>
<tr>
<td><strong>集合</strong></td>
<td>无序、可变、唯一性（自动去重）</td>
<td>哈希表（仅键）</td>
<td>去重、集合运算（交集、并集）、成员判断</td>
</tr>
<tr>
<td><strong>字符串</strong></td>
<td>有序、不可变、字符序列</td>
<td>动态编码机制存储字符，如UTF-8、GBK</td>
<td>文本处理、数据序列化（JSON&#x2F;XML格式）</td>
</tr>
</tbody></table>
<h3 id="Python-函数参数的传递机制"><a href="#Python-函数参数的传递机制" class="headerlink" title="Python 函数参数的传递机制"></a>Python 函数参数的传递机制</h3><p>Python的函数参数传递机制是对象引用传递（Pass by Object Reference），其核心是传递对象的引用，而非对象本身或对象的值。这一机制的行为取决于对象是否可变。</p>
<p><strong>1. 如何理解对象引用传递</strong></p>
<ul>
<li><strong>所有变量都是对象的引用</strong>：Python中变量名本质上是对象的引用（指针），即所有数据（如整数、字符串、列表等）都以对象形式存在，变量仅指向这些对象。</li>
<li><strong>传递的是引用的拷贝</strong>：函数调用时，实参对象的引用（地址）会被拷贝给形参。因此，形参和实参<strong>指向同一个对象</strong>，但引用本身是独立的。</li>
</ul>
<p><strong>2. 不可变对象的传递</strong></p>
<p><strong>不可变对象</strong>（如 <code>int</code>、<code>str</code>、<code>tuple</code> 等）的值不能被修改，因此：</p>
<ul>
<li><strong>函数内部无法修改原对象</strong>：对形参的“修改”都会创建新对象（如重新赋值），外部变量不变，行为类似“值传递”</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">modify_immutable</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;函数内原始x的id: <span class="subst">&#123;<span class="built_in">id</span>(x)&#125;</span>&quot;</span>)</span><br><span class="line">    x = <span class="number">10</span>  <span class="comment"># 创建新对象，原引用被替换</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;修改后x的id: <span class="subst">&#123;<span class="built_in">id</span>(x)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">x = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;调用前x的id: <span class="subst">&#123;<span class="built_in">id</span>(x)&#125;</span>&quot;</span>)</span><br><span class="line">modify_immutable(x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;调用后x的值: <span class="subst">&#123;x&#125;</span>&quot;</span>)  <span class="comment"># 输出：5（未改变）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># 调用前x的id: 4353896768</span></span><br><span class="line"><span class="comment"># 函数内原始x的id: 4353896768</span></span><br><span class="line"><span class="comment"># 修改后x的id: 4353896928</span></span><br><span class="line"><span class="comment"># 调用后x的值: 5</span></span><br></pre></td></tr></table></figure>

<p><strong>3.可变对象的传递</strong></p>
<p><strong>可变对象</strong>（如 <code>list</code>、<code>dict</code>、<code>set</code> 等）的值可以被修改，因此：</p>
<ul>
<li><strong>函数内部可直接修改原对象</strong>：通过原地操作（如 <code>append</code>、<code>update</code>）会修改原对象，会影响外部变量，行为类似“引用传递”</li>
<li>特殊情况：如果在函数内部重新赋值（如 lst &#x3D; new_list），形参的引用会指向新对象，外部变量不变</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">modify_mutable</span>(<span class="params">lst</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;函数内原始lst的id: <span class="subst">&#123;<span class="built_in">id</span>(lst)&#125;</span>&quot;</span>)</span><br><span class="line">    lst.append(<span class="number">4</span>)  <span class="comment"># 原地修改，对象内容改变</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;原地修改后lst的id: <span class="subst">&#123;<span class="built_in">id</span>(lst)&#125;</span>&quot;</span>)</span><br><span class="line">    lst = [<span class="number">100</span>, <span class="number">200</span>]  <span class="comment"># 此处重新赋值，形参lst指向新对象，但原my_list未受影响</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;重新赋值后lst的id: <span class="subst">&#123;<span class="built_in">id</span>(lst)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;调用前my_list的id: <span class="subst">&#123;<span class="built_in">id</span>(my_list)&#125;</span>&quot;</span>)</span><br><span class="line">modify_mutable(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;调用后my_list的内容: <span class="subst">&#123;my_list&#125;</span>&quot;</span>)  <span class="comment"># 输出：[1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># 调用前my_list的id: 4408370176</span></span><br><span class="line"><span class="comment"># 函数内原始lst的id: 4408370176</span></span><br><span class="line"><span class="comment"># 原地修改后lst的id: 4408370176</span></span><br><span class="line"><span class="comment"># 重新赋值后lst的id: 4404760832</span></span><br><span class="line"><span class="comment"># 调用后my_list的内容: [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h3 id="Python-垃圾回收机制"><a href="#Python-垃圾回收机制" class="headerlink" title="Python 垃圾回收机制"></a>Python 垃圾回收机制</h3><p>Python的垃圾回收（Garbage Collection, GC）机制旨在自动管理内存，回收不再被使用的对象，避免内存泄漏。其核心机制结合了引用计数和分代回收（Generational Collection），同时通过gc模块提供手动控制的灵活性。</p>
<p><strong>1. 核心机制：引用计数</strong></p>
<p><strong>基本原理</strong></p>
<ul>
<li><strong>每个对象都有一个引用计数器</strong>：记录当前有多少变量或对象引用它。</li>
<li>引用计数的增减：<ul>
<li>当对象被创建时，初始引用计数为1。</li>
<li>每次有新的变量或对象引用该对象时，计数器加1。</li>
<li>当引用失效（如变量被删除、超出作用域、重新赋值）时，计数器减1。</li>
<li><strong>当计数器降为0时</strong>，Python立即释放该对象的内存。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  <span class="comment"># 列表对象的引用计数为1（被a引用）</span></span><br><span class="line">b = a          <span class="comment"># 引用计数变为2（被a和b引用）</span></span><br><span class="line"><span class="keyword">del</span> a          <span class="comment"># 引用计数减为1（仅b引用）</span></span><br><span class="line">b = <span class="literal">None</span>       <span class="comment"># 引用计数降为0，列表对象被回收</span></span><br></pre></td></tr></table></figure>

<p><strong>引用计数的局限性</strong></p>
<ul>
<li>无法处理循环引用：当两个或多个对象互相引用时，引用计数永远不会为0，导致内存泄漏。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = []</span><br><span class="line">b = []</span><br><span class="line">a.append(b)   <span class="comment"># a引用b</span></span><br><span class="line">b.append(a)   <span class="comment"># b引用a</span></span><br><span class="line"><span class="keyword">del</span> a, b      <span class="comment"># 循环引用的计数仍为1，无法回收</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>分代回收（Generational Collection）</strong></li>
</ol>
<p>作用：解决循环引用问题，通过周期性扫描检测并回收被循环引用的对象。</p>
<p>分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。</p>
<h3 id="函数装饰器有什么作用？请列举说明"><a href="#函数装饰器有什么作用？请列举说明" class="headerlink" title="函数装饰器有什么作用？请列举说明"></a>函数装饰器有什么作用？请列举说明</h3><p>函数装饰器可以在不修改原函数的条件下，为原函数添加额外的功能，例如记录日志，运行性能，缓存等</p>
<h3 id="简述-classmethod-和-staticmethod-用法和区别"><a href="#简述-classmethod-和-staticmethod-用法和区别" class="headerlink" title="简述 @classmethod 和 @staticmethod 用法和区别"></a>简述 @classmethod 和 @staticmethod 用法和区别</h3><table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong><code>@classmethod</code></strong></th>
<th><strong><code>@staticmethod</code></strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>参数</strong></td>
<td>必须有 <code>cls</code>（类本身）</td>
<td>无特殊参数，类似普通函数</td>
</tr>
<tr>
<td><strong>访问权限</strong></td>
<td>可访问&#x2F;修改类属性</td>
<td>无法访问类或实例属性</td>
</tr>
<tr>
<td><strong>依赖性</strong></td>
<td>依赖类的上下文</td>
<td>与类或实例无关</td>
</tr>
<tr>
<td><strong>典型用途</strong></td>
<td>工厂方法（替代构造函数来创建对象）、操作类属性、多态场景</td>
<td>工具函数、逻辑相关但独立的功能</td>
</tr>
<tr>
<td><strong>调用灵活性</strong></td>
<td>推荐通过类名调用</td>
<td>推荐通过类名调用</td>
</tr>
</tbody></table>
<h3 id="你了解-Python-中的反射吗？"><a href="#你了解-Python-中的反射吗？" class="headerlink" title="你了解 Python 中的反射吗？"></a>你了解 Python 中的反射吗？</h3><p>Python 的反射能力由一系列内置函数和模块支持，允许代码在运行时根据字符串名称操作对象，实现高度动态的编程。比如动态操作对象属性、调用方法、模块导入等</p>
<p><strong>内置函数</strong></p>
<ol>
<li><code>hasattr(obj, name)</code>: 检查对象是否包含指定属性&#x2F;方法</li>
<li><code>getattr(obj, name, default)</code>: 获取对象的属性&#x2F;方法，若不存在则返回 <code>default</code> 或抛出错误</li>
<li><code>setattr(obj, name, value)</code>: 动态设置对象的属性值</li>
<li><code>delattr(obj, name)</code>: 删除对象中的属性&#x2F;方法</li>
</ol>
<p><strong>应用场景</strong></p>
<p>1、动态调用方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Http</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self,url</span>):</span><br><span class="line">        res = requests.get(url)</span><br><span class="line">        response = res.text</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self,url</span>):</span><br><span class="line">        res = requests.post(url)</span><br><span class="line">        response = res.text</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用反射后</span></span><br><span class="line">url = <span class="string">&quot;https://www.jianshu.com/u/14140bf8f6c7&quot;</span></span><br><span class="line">method = <span class="built_in">input</span>(<span class="string">&quot;请求方法&gt;&gt;&gt;:&quot;</span>)</span><br><span class="line">h = Http()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">hasattr</span>(h,method):</span><br><span class="line">    func = <span class="built_in">getattr</span>(h,method)</span><br><span class="line">    res = func(url)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你的请求方式有误...&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>2、动态属性操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicObject</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">obj = DynamicObject()</span><br><span class="line"><span class="built_in">setattr</span>(obj, <span class="string">&quot;dynamic_attr&quot;</span>, <span class="number">42</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(obj, <span class="string">&quot;dynamic_attr&quot;</span>))  <span class="comment"># 输出 42</span></span><br></pre></td></tr></table></figure>

<p>3、动态加载模块或类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">module_name = <span class="string">&quot;math&quot;</span></span><br><span class="line">module = <span class="built_in">__import__</span>(module_name)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(module, <span class="string">&quot;sqrt&quot;</span>)(<span class="number">16</span>))  <span class="comment"># 输出 4.0</span></span><br></pre></td></tr></table></figure>

<p><strong>inspect 模块</strong></p>
<p><code>inspect</code> 模块提供更强大的内省功能。</p>
<p>严格来说，内省是反射的一部分，主要用于查看分析函数&#x2F;类的元数据。简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance()。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;示例函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取函数参数信息</span></span><br><span class="line"><span class="built_in">print</span>(inspect.signature(my_function))  <span class="comment"># 输出 (a, b)</span></span><br><span class="line"><span class="comment"># 获取文档字符串</span></span><br><span class="line"><span class="built_in">print</span>(inspect.getdoc(my_function))     <span class="comment"># 输出 &quot;示例函数&quot;</span></span><br><span class="line"><span class="comment"># 获取源代码</span></span><br><span class="line"><span class="built_in">print</span>(inspect.getsource(my_function))  <span class="comment"># 输出函数定义的源代码</span></span><br></pre></td></tr></table></figure>

<h3 id="copy-和-deepcopy-的区别是什么？"><a href="#copy-和-deepcopy-的区别是什么？" class="headerlink" title="copy 和 deepcopy 的区别是什么？"></a>copy 和 deepcopy 的区别是什么？</h3><p><strong>浅拷贝:</strong> 创建新对象，赋值的时候非递归地复制子对象的引用。</p>
<p><strong>深拷贝：</strong>创建新对象，赋值的时候递归地复制子对象的引用。即拷贝了对象的所有元素，包括多层嵌套的元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]]  <span class="comment">#原始对象</span></span><br><span class="line"></span><br><span class="line">b = a  <span class="comment">#赋值，传对象的引用</span></span><br><span class="line">c = copy.copy(a)  <span class="comment">#对象拷贝，浅拷贝</span></span><br><span class="line">d = copy.deepcopy(a)  <span class="comment">#对象拷贝，深拷贝</span></span><br><span class="line"></span><br><span class="line">a.append(<span class="number">5</span>)  <span class="comment">#修改对象a</span></span><br><span class="line">a[<span class="number">4</span>].append(<span class="string">&#x27;c&#x27;</span>)  <span class="comment">#修改对象a中的[&#x27;a&#x27;, &#x27;b&#x27;]数组对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a = &#x27;</span>, a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b = &#x27;</span>, b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c = &#x27;</span>, c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;d = &#x27;</span>, d)</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">5</span>]</span><br><span class="line">b =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">5</span>]</span><br><span class="line">c =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]]</span><br><span class="line">d =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><ul>
<li>进程是CPU资源分配的基本单位，线程是独立运行与调度的基本单位（CPU上真正运行的是线程）</li>
<li>进程拥有自己的资源空间，同一个进程中的多个线程并发执行，这些线程共享进程所拥有的资源，但需处理线程安全问题（如锁机制）</li>
<li>线程的调度与切换比进程快很多</li>
</ul>
<h3 id="python中的GIL"><a href="#python中的GIL" class="headerlink" title="python中的GIL"></a>python中的GIL</h3><p>CPython环境下，每个进程都拥有一个GIL(Global Interpreter Lock)，单进程下的多线程，某个线程想要执行，必须先获取GIL，才可以进入CPU执行。因此，一个Python进程中的多个线程不能同时使用多个CPU核心（java中一个进程中的多线程可以利用多核cpu）。</p>
<p>GIL释放的情况：</p>
<ol>
<li>执行的字节码行数到达一定阈值</li>
<li>通过时间片划分，到达一定时间阈值</li>
<li>在遇到IO操作时，主动释放</li>
</ol>
<p><strong>GIL（全局解释器锁）带来的影响</strong></p>
<p><strong>多线程</strong>：</p>
<ul>
<li>Python 的  GIL 会强制解释器在同一时刻只能执行一个线程的字节码。因此，<strong>多线程在 CPU 密集型任务中无法真正并行</strong>，反而可能因线程切换导致效率下降。</li>
<li>不过Python标准库中的所有阻塞型I&#x2F;O函数都会释放GIL，等待 IO 时可以切换线程执行其他任务，因此<strong>多线程适合 IO 密集型任务</strong>（如网络请求、爬虫、文件读写）</li>
</ul>
<p><strong>多进程</strong>：</p>
<ul>
<li>每个进程拥有独立的 Python 解释器和 GIL，因此<strong>多进程可以并行利用多核 CPU，适合 CPU 密集型任务</strong>（如科学计算、数据处理）</li>
</ul>
<h3 id="python-协程是什么"><a href="#python-协程是什么" class="headerlink" title="python 协程是什么"></a>python 协程是什么</h3><p><strong>协程是一种比线程更加轻量级的存在，最重要的是，协程不被操作系统内核管理，协程是完全由程序控制的。</strong></p>
<ul>
<li>运行效率极高，协程的切换完全由程序控制，不像线程切换需要花费操作系统的开销，线程数量越多，协程的优势就越明显。</li>
<li>协程不需要多线程的锁机制，因为只有一个线程，不存在变量冲突。</li>
<li>对于多核CPU，利用多进程+协程的方式，能充分利用CPU，获得极高的性能。</li>
</ul>
<p>Python里最常见的yield就是协程的思想!</p>
<h3 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h3><p>单例模式的主要目的是保证在系统中，某个类只能有一个实例存在。比如保存系统基本配置信息的类，在很多地方都要用到，没有必要频繁创建实例与销毁实例，只需要保存一个全局的实例对象即可，这样可以减少对内存资源的占用。</p>
<p>1、可以在模块中定义单例类并实例化对象，在用的时候直接导入这个模块的实例对象即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GlobalConfig</span>:</span><br><span class="line">    host = <span class="string">&#x27;xxx.xxx&#x27;</span></span><br><span class="line">    port = <span class="number">3306</span></span><br><span class="line">    username = <span class="string">&#x27;username&#x27;</span></span><br><span class="line">    password = <span class="string">&#x27;123123&#x27;</span></span><br><span class="line"></span><br><span class="line">g = GlobalConfig()</span><br></pre></td></tr></table></figure>

<p>2、<code>__new__()</code>是类的构造方法，在实例创建前被调用，它的作用就是创建实例对象。利用这个方法和类的属性的特点可以实现设计模式的单例模式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多线程下创建单例对象需要加锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>:</span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 加锁</span></span><br><span class="line">        <span class="keyword">with</span> cls._instance_lock:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&#x27;instance&#x27;</span>):</span><br><span class="line">                cls.instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    s = Singleton()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;s:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>(s)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        td = threading.Thread(target=func)</span><br><span class="line">        td.start()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试理论与知识总结</title>
    <url>/2022/01/10/testing-theory/</url>
    <content><![CDATA[<hr>
<h2 id="软件质量模型"><a href="#软件质量模型" class="headerlink" title="软件质量模型"></a>软件质量模型</h2><p>软件质量模型是一组特性及特性之间的关系，它提供规定质量需求和评价质量的基础。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>核心子特性</th>
</tr>
</thead>
<tbody><tr>
<td><strong>功能性</strong></td>
<td>适合性、准确性、互操作性、安全性</td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td>成熟性（无故障）、容错性（出了故障不影响主功能）、可恢复性（快速恢复）</td>
</tr>
<tr>
<td><strong>易用性</strong></td>
<td>易理解性、易学性、易操作性</td>
</tr>
<tr>
<td><strong>效率</strong></td>
<td>时间特性（RT≤2s）、资源利用率（CPU≤80%）</td>
</tr>
<tr>
<td><strong>可维护性</strong></td>
<td>可分析性、可修改性、稳定性、易测试性</td>
</tr>
<tr>
<td><strong>可移植性</strong></td>
<td>适应性（环境兼容）、易安装性、共存性（与其他系统共存）</td>
</tr>
</tbody></table>
<hr>
<h2 id="测试思维与方法"><a href="#测试思维与方法" class="headerlink" title="测试思维与方法"></a>测试思维与方法</h2><h3 id="测试思维"><a href="#测试思维" class="headerlink" title="测试思维"></a>测试思维</h3><ul>
<li><strong>批判性思维</strong>：基于观察、分析、推理，持续质疑系统，优化测试设计。</li>
<li><strong>系统性思维</strong>：从整体到局部分析被测对象，对系统进行分解、分层（如分层测试策略）。</li>
<li><strong>发散性思维</strong>：多角度探索用户场景（如探索式测试中的路径多样性）。</li>
</ul>
<h3 id="黑盒测试方法"><a href="#黑盒测试方法" class="headerlink" title="黑盒测试方法"></a>黑盒测试方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>核心逻辑</th>
</tr>
</thead>
<tbody><tr>
<td><strong>场景法</strong></td>
<td>模拟用户操作流程，覆盖基本流（正确流程）和备选流（异常流程）。</td>
</tr>
<tr>
<td><strong>等价类划分</strong></td>
<td>将输入划分为有效&#x2F;无效等价类，每类选一个用例覆盖。</td>
</tr>
<tr>
<td><strong>边界值分析</strong></td>
<td>测试输入边界值（如最大值、最小值、空值）。</td>
</tr>
<tr>
<td><strong>因果图</strong></td>
<td>分析输入条件与输出的因果关系，生成判定表设计用例。</td>
</tr>
<tr>
<td><strong>错误猜测法</strong></td>
<td>基于经验测试易错点，以点带面地挖掘共性bug（如特殊字符、越权漏洞测试）。</td>
</tr>
</tbody></table>
<h3 id="白盒测试方法"><a href="#白盒测试方法" class="headerlink" title="白盒测试方法"></a>白盒测试方法</h3><ul>
<li><strong>语句覆盖</strong>：每条代码至少执行一次。</li>
<li><strong>判定覆盖</strong>：每个分支的真&#x2F;假至少执行一次。</li>
<li><strong>条件覆盖</strong>：每个条件表达式取真&#x2F;假至少一次。</li>
<li><strong>路径覆盖</strong>：覆盖所有可能的执行路径（理论最高覆盖，但成本高）。</li>
</ul>
<h3 id="推荐的综合策略"><a href="#推荐的综合策略" class="headerlink" title="推荐的综合策略"></a><strong>推荐的综合策略</strong></h3><p><strong>对于大多数云原生系统的状态测试</strong>，推荐混合使用状态转换测试（主干）+ 因果图（异常分支）+ 场景测试（并发&#x2F;时序），以平衡覆盖率和执行成本。</p>
<ol>
<li><strong>分层测试设计</strong><ul>
<li><strong>主干逻辑</strong>：使用<strong>状态转换测试</strong>覆盖实例状态机（如<code>Running</code>→<code>Stopped</code>→<code>Deleted</code>）。</li>
<li><strong>复杂分支</strong>：用因果图覆盖异常场景（如资源不足、节点故障）。</li>
<li><strong>并发和时序</strong>：补充基于场景的测试或混沌实验。</li>
</ul>
</li>
<li><strong>用例混合设计示例</strong></li>
</ol>
<ul>
<li>用例1（状态转换）：Running → Stop → Stopped  </li>
<li>用例2（因果图）：Create + ResourceExhausted → Error  </li>
<li>用例3（并发场景）：Create和Delete同时触发 → 操作冲突提示</li>
</ul>
<hr>
<h2 id="测试流程与敏捷实践"><a href="#测试流程与敏捷实践" class="headerlink" title="测试流程与敏捷实践"></a>测试流程与敏捷实践</h2><h3 id="传统测试流程"><a href="#传统测试流程" class="headerlink" title="传统测试流程"></a>传统测试流程</h3><ol>
<li><strong>需求分析</strong>：明确测试范围与优先级。</li>
<li><strong>测试计划</strong>：制定目标、策略、风险应对方案。</li>
<li><strong>测试设计</strong>：转化为具体用例（等价类、场景法等）。</li>
<li><strong>测试执行</strong>：执行自测、回归测试、缺陷跟踪。</li>
<li><strong>发布维护</strong>：监控线上问题并修复。</li>
</ol>
<h3 id="敏捷测试流程"><a href="#敏捷测试流程" class="headerlink" title="敏捷测试流程"></a>敏捷测试流程</h3><p>敏捷测试本质是短、频、快地反馈代码提交的质量，促进持续交付。</p>
<img src="/2022/01/10/testing-theory/image-20250212001852714.png" class="" title="image-20250212001852714">

<p>敏捷测试的特点如下：</p>
<ul>
<li><strong>质量内建</strong>：测试左移（参与需求评审） + 测试右移（监控生产环境）。</li>
<li><strong>持续测试</strong>：自动化与探索式测试结合，快速反馈代码质量。</li>
<li><strong>分层策略</strong>：单元测试→接口测试→UI测试，平衡效率与覆盖。</li>
</ul>
<h3 id="探索式测试（ET）"><a href="#探索式测试（ET）" class="headerlink" title="探索式测试（ET）"></a>探索式测试（ET）</h3><p>探索式测试旨在将学习、测试设计、测试执行和测试结果分析做为一个循环快速地迭代，在较短的时间内（如1个小时）完成多次循环，以持续优化测试。该思路再次与敏捷软件开发小步快跑、持续反馈的理念不谋而合。</p>
<ul>
<li><strong>核心</strong>：质疑系统存在漏洞（需求误解、实现错误、性能瓶颈等）。</li>
<li><strong>实施步骤</strong>：  <ol>
<li>制定SMART目标（具体、可度量、可实现）。  </li>
<li>分时间盒（如50分钟）执行“设计-执行-分析”循环。  </li>
<li>通过测程管理（SBTM）记录测试结果并复盘。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><h3 id="测试类型"><a href="#测试类型" class="headerlink" title="测试类型"></a>测试类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>目标</th>
</tr>
</thead>
<tbody><tr>
<td><strong>负载测试</strong></td>
<td>确定系统在满足性能指标下的最大负载，同时可找到性能下降拐点（如响应时间≤2s时支持1万用户）。</td>
</tr>
<tr>
<td><strong>压力测试</strong></td>
<td>测试系统在极端负载下的稳定性和可靠性（如用户量继续增加导致系统崩溃的临界点）。</td>
</tr>
<tr>
<td><strong>容量测试</strong></td>
<td>验证系统处理数据量&#x2F;用户量的极限（如云存储最大数据量）。</td>
</tr>
</tbody></table>
<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><table>
<thead>
<tr>
<th>指标</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>响应时间 (RT)</strong></td>
<td>用户发起请求到收到响应的总时间（含网络传输、后端服务处理、前端渲染）。</td>
</tr>
<tr>
<td><strong>吞吐率（TPS）</strong></td>
<td>每秒处理的事务数（衡量系统整体吞吐能力）。</td>
</tr>
<tr>
<td><strong>QPS</strong></td>
<td>每秒处理的请求数（公式：QPS &#x3D; 并发用户数 &#x2F; 平均响应时间）。</td>
</tr>
</tbody></table>
<h2 id="可靠性测试"><a href="#可靠性测试" class="headerlink" title="可靠性测试"></a>可靠性测试</h2><ul>
<li><p><strong>定义</strong>：验证系统在特定条件下（如长时间运行、异常输入、资源限制等）持续稳定运行的能力，确保其在设计预期内无故障运行或快速恢复。</p>
</li>
<li><p><strong>核心目标</strong>：</p>
<ul>
<li>发现系统潜在缺陷（如内存泄漏、死锁、资源耗尽）。</li>
<li>验证系统在异常场景下的容错能力（如网络抖动、磁盘故障）。</li>
<li>评估系统恢复时间（MTTR，Mean Time To Recovery）。</li>
</ul>
</li>
<li><p><strong>典型测试场景</strong>：</p>
<ul>
<li>长时间压力测试（7×24小时运行）。</li>
<li>模拟硬件故障（如强制关闭虚拟机节点）。</li>
<li>异常输入测试（如无效请求、超大数据包）。</li>
</ul>
</li>
<li><p><strong>与高可用测试的区别</strong>：</p>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">可靠性测试</th>
<th align="left">高可用测试</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>侧重点</strong></td>
<td align="left">系统整体稳定性与容错能力</td>
<td align="left">故障时服务的持续可用性</td>
</tr>
<tr>
<td align="left"><strong>范围</strong></td>
<td align="left">更广泛（覆盖所有异常场景）</td>
<td align="left">更聚焦（仅针对故障场景的可用性）</td>
</tr>
<tr>
<td align="left"><strong>典型指标</strong></td>
<td align="left">MTBF（平均无故障时间）、MTTR</td>
<td align="left">SLA（如99.99%可用性）、RTO（恢复时间目标）</td>
</tr>
<tr>
<td align="left"><strong>设计原则</strong></td>
<td align="left">容错设计、代码健壮性</td>
<td align="left">冗余架构、故障转移机制</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="测试之道"><a href="#测试之道" class="headerlink" title="测试之道"></a>测试之道</h2><p>在软件工程领域，测试不仅是发现缺陷的手段，更是贯穿产品生命周期的质量反馈机制。以下结合理论与测试实践，对测试工作的核心逻辑进行分析和总结，并探讨其深层意义。</p>
<h3 id="测试的本质是反馈：反馈驱动质量改进"><a href="#测试的本质是反馈：反馈驱动质量改进" class="headerlink" title="测试的本质是反馈：反馈驱动质量改进"></a><strong>测试的本质是反馈：反馈驱动质量改进</strong></h3><ul>
<li>根据ISTQB（国际软件测试资格认证委员会）的定义，测试的核心目标之一是<strong>提供质量相关信息</strong>。测试结果无论成功与否，均能为团队提供关键信息：  <ul>
<li><strong>通过</strong>：验证功能符合预期，增强信心。  </li>
<li><strong>失败</strong>：暴露问题，推动改进。</li>
</ul>
</li>
<li>例如，自动化测试的稳定性监控（如每日构建）能够反馈代码变更对系统的影响，即使未发现新缺陷，也能反映当前版本的可靠性。</li>
</ul>
<p><strong>启示</strong>：测试不仅是技术的实践，更是质量的哲学。唯有将反馈思维融入每个环节，才能让测试从“成本中心”蜕变为“价值引擎”。</p>
<h3 id="测试人员的价值：质量的全链路守护者"><a href="#测试人员的价值：质量的全链路守护者" class="headerlink" title="测试人员的价值：质量的全链路守护者"></a><strong>测试人员的价值：质量的全链路守护者</strong></h3><ul>
<li>在敏捷和DevOps实践中，测试角色已从“质检员”转变为<strong>质量赋能者</strong>。测试人员需：  <ul>
<li><strong>发现缺陷</strong>：通过设计用例覆盖复杂场景。  </li>
<li><strong>定位问题</strong>：结合日志、监控和代码分析，缩短排查路径（如通过APM工具追踪性能瓶颈）。  </li>
<li><strong>推动解决</strong>：参与根因分析，提出可落地的优化建议（如优化数据库索引）。</li>
</ul>
</li>
<li>例如，某电商系统在高并发下单时出现超卖，测试人员通过压力测试复现问题后，协助开发引入分布式锁机制，最终解决缺陷。</li>
</ul>
<p><strong>启示</strong>：测试人员的价值不仅在于“发现问题”，更在于<strong>加速问题闭环</strong>。</p>
<h3 id="测试的充分性：始于需求分析，而非用例设计"><a href="#测试的充分性：始于需求分析，而非用例设计" class="headerlink" title="测试的充分性：始于需求分析，而非用例设计"></a><strong>测试的充分性：始于需求分析，而非用例设计</strong></h3><ul>
<li>测试遗漏常源于<strong>需求盲区</strong>。例如： 某支付系统因需求未明确“余额不足时的重试逻辑”，导致测试未覆盖，上线后引发重复扣款。  </li>
<li>解决方法：  <ul>
<li><strong>早期介入</strong>：测试参与需求评审，识别模糊点（如通过实例化需求方法）。  </li>
<li><strong>需求可测性</strong>：将非功能性需求（如性能、安全）纳入分析范围。</li>
</ul>
</li>
</ul>
<p><strong>启示</strong>：测试充分性的天花板在需求阶段已确定，测试设计只是实现手段。</p>
<h3 id="测试的有效性：效率与价值的平衡"><a href="#测试的有效性：效率与价值的平衡" class="headerlink" title="测试的有效性：效率与价值的平衡"></a><strong>测试的有效性：效率与价值的平衡</strong></h3><ul>
<li><strong>风险驱动测试</strong>：优先覆盖高概率、高影响的场景（如核心支付链路）。  </li>
<li><strong>自动化分层策略</strong>：金字塔模型（单元测试70%、接口测试20%、UI测试10%）优化执行效率。</li>
</ul>
<p><strong>启示</strong>：在有限资源下，测试需聚焦<strong>关键质量目标</strong>，而非盲目追求覆盖率100%。</p>
<h3 id="缺陷的确定性：科学方法破除“玄学”"><a href="#缺陷的确定性：科学方法破除“玄学”" class="headerlink" title="缺陷的确定性：科学方法破除“玄学”"></a><strong>缺陷的确定性：科学方法破除“玄学”</strong></h3><ul>
<li>无法重现的问题，就说明我们不知道问题到底是什么。</li>
<li><strong>缺陷复现三要素</strong>：环境、数据、操作步骤的一致性。  </li>
<li>案例：某服务间歇性超时，通过逐步隔离变量（网络延迟、线程池配置、依赖服务状态），最终定位为数据库连接泄漏。</li>
</ul>
<p><strong>启示</strong>：缺陷排查是<strong>系统性实验</strong>，需用控制变量法定位根因，而非运气游戏。</p>
<h3 id="杀虫剂悖论：测试的进化法则"><a href="#杀虫剂悖论：测试的进化法则" class="headerlink" title="杀虫剂悖论：测试的进化法则"></a><strong>杀虫剂悖论：测试的进化法则</strong></h3><ul>
<li><strong>悖论本质</strong>：重复相同的测试会逐渐降低缺陷发现率（Boris Beizer, 1990）。  </li>
<li>应对策略：  <ul>
<li><strong>用例维护</strong>：随需求变更同步更新（如版本迭代后删除过期用例）。  </li>
<li><strong>变异测试</strong>：人工修改代码生成缺陷，验证用例是否捕获。  </li>
<li><strong>探索式测试</strong>：每周2小时自由探索，记录意外问题。</li>
</ul>
</li>
</ul>
<p><strong>启示</strong>：测试资产是<strong>活文档</strong>，需持续迭代以匹配系统演进。</p>
<h3 id="测试左移与右移：质量共同体建设"><a href="#测试左移与右移：质量共同体建设" class="headerlink" title="测试左移与右移：质量共同体建设"></a><strong>测试左移与右移：质量共同体建设</strong></h3><ul>
<li><strong>测试左移</strong>：  <ul>
<li><strong>需求阶段</strong>：与产品共建，通过实例化需求（Specification by Example）定义验收标准，避免歧义。例如，使用Gherkin语法编写用户故事，直接生成自动化测试用例。  </li>
<li><strong>开发阶段</strong>：与开发协作，推动单元测试与代码评审，结合SonarQube等工具检测代码坏味道。</li>
</ul>
</li>
<li><strong>测试右移</strong>：  <ul>
<li><strong>运维阶段</strong>：与运维协作，生产环境通过监控（如Prometheus）、日志（如ELK）和A&#x2F;B测试验证实际用户场景。  </li>
<li><strong>混沌工程</strong>：利用混沌工程工具（Chaos Mesh）模拟生产故障（如网络分区、节点宕机），验证系统韧性。</li>
</ul>
</li>
</ul>
<p><strong>启示：</strong>测试活动应贯穿需求、开发、交付、运维的全生命周期。  </p>
<h3 id="质量指标可视化：从经验主义到科学决策"><a href="#质量指标可视化：从经验主义到科学决策" class="headerlink" title="质量指标可视化：从经验主义到科学决策"></a><strong>质量指标可视化：从经验主义到科学决策</strong></h3><ul>
<li><strong>缺陷模式分析</strong>：  <ul>
<li>通过历史缺陷数据识别高频问题模块（如支付服务占线上缺陷的40%），针对性增强测试覆盖。  </li>
<li>使用热图（Heatmap）标记代码改动频繁的区域，优先测试。</li>
</ul>
</li>
<li><strong>效果度量</strong>：  <ul>
<li>定义核心指标：缺陷逃逸率（&lt;5%）、测试用例有效性（缺陷发现数&#x2F;用例数）、自动化ROI（&gt;1:3）；</li>
<li>搭建质量看板：Grafana集成Jira、Jenkins数据；</li>
<li>每周同步：在站会上展示指标趋势，驱动改进</li>
</ul>
</li>
</ul>
<p><strong>启示</strong>：测试策略应基于数据而非直觉，包括测试优先级、资源分配和风险评估。  </p>
<h3 id="自动化不是银弹：平衡人机协作"><a href="#自动化不是银弹：平衡人机协作" class="headerlink" title="自动化不是银弹：平衡人机协作"></a><strong>自动化不是银弹：平衡人机协作</strong></h3><ul>
<li><strong>自动化适用场景</strong>：  <ul>
<li>高频回归（如核心链路）、数据驱动测试（如参数组合）、精准重复操作（如性能测试）。</li>
</ul>
</li>
<li><strong>探索式测试优势</strong>：  <ul>
<li>发现“意料之外”的问题（如界面渲染异常、多步骤交互副作用）。  </li>
<li>快速验证新功能逻辑，弥补自动化滞后性。</li>
</ul>
</li>
<li><strong>平衡策略</strong>：  <ul>
<li>80%核心场景自动化 + 20%探索式测试覆盖长尾场景。  </li>
<li>使用Session-Based Test Management（SBTM）管理探索式测试过程。</li>
</ul>
</li>
</ul>
<p><strong>启示</strong>：自动化解决效率问题，探索式测试（ET）解决认知问题，二者缺一不可。</p>
<h3 id="测试工程师的核心竞争力：技术深度与业务广度的平衡"><a href="#测试工程师的核心竞争力：技术深度与业务广度的平衡" class="headerlink" title="测试工程师的核心竞争力：技术深度与业务广度的平衡"></a><strong>测试工程师的核心竞争力：技术深度与业务广度的平衡</strong></h3><p><strong>技术能力</strong>：  </p>
<ul>
<li>读懂代码逻辑：快速定位缺陷根源（如空指针异常、事务未提交）。  </li>
<li>理解系统架构：设计分布式场景测试（如Redis缓存一致性、MQ消息幂等）。</li>
</ul>
<p><strong>业务能力</strong>：  </p>
<ul>
<li>掌握领域知识：金融测试需理解清算规则、医疗系统需符合HL7协议。  </li>
<li>用户视角思维：从用户操作路径设计端到端场景（如电商下单→支付→退货）。</li>
</ul>
<p><strong>提升路径</strong>：</p>
<ul>
<li><strong>技术深度</strong>：每月研究一个开源项目（如Kubernetes测试框架）；</li>
<li><strong>业务广度</strong>：季度性轮岗（如参与产品需求设计）；</li>
<li><strong>自动化思维</strong>：将重复工作脚本化（如用Python自动生成测试报告）</li>
</ul>
]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Python编程进阶：装饰器的使用</title>
    <url>/2020/02/06/python-decorator/</url>
    <content><![CDATA[<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>在Python开发中，装饰器（Decorator）是一种强大而优雅的语法特性，它允许在<strong>不修改原函数代码</strong>的前提下，动态地为函数添加额外功能（如日志记录、性能分析、参数校验等）。本文将从闭包的基础概念出发，深入解析装饰器的实现原理，并通过实际示例展示其应用场景。</p>
<hr>
<h3 id="闭包：装饰器的基石"><a href="#闭包：装饰器的基石" class="headerlink" title="闭包：装饰器的基石"></a>闭包：装饰器的基石</h3><p>在理解装饰器之前，必须先了解<strong>闭包（Closure）</strong>的概念。闭包是指在函数内部定义的函数（嵌套函数），该函数可以访问外层函数的变量，即使外层函数已经执行完毕。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    x = <span class="number">10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;通过闭包访问外层变量x的值: <span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner	<span class="comment"># 返回闭包</span></span><br><span class="line"></span><br><span class="line">closure = outer()</span><br><span class="line">closure()  <span class="comment"># 输出: 通过闭包访问外层变量x的值: 10</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>outer</code> 返回 <code>inner</code>，后者可以访问并使用 <code>outer</code> 中的变量 <code>x</code></p>
<h3 id="装饰器的实现"><a href="#装饰器的实现" class="headerlink" title="装饰器的实现"></a>装饰器的实现</h3><p>装饰器的本质是一个接收函数作为参数的外层函数，其内部定义一个闭包（通常命名为<code>wrapper</code>），用于包裹原函数并增强其功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 装饰器模版</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):          <span class="comment"># 外层函数（装饰器）</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):  <span class="comment"># 内层函数（闭包）</span></span><br><span class="line">        <span class="comment"># do something</span></span><br><span class="line">        result = func(*args, **kwargs)	<span class="comment"># 访问外层函数的参数 `func`</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>decorator</code>就是一个装饰器。它接受一个函数<code>func</code>作为参数，并返回一个包裹原函数的新函数<code>wrapper</code>。</p>
<p><strong>代码解析</strong></p>
<ol>
<li><code>@wraps(func)</code> ：保留原函数的元数据（如函数名、文档信息）</li>
<li><code>*args, **kwargs</code>：接受任意、不定数量的参数，增强装饰器的通用性。</li>
<li>外层<code>return wrapper</code>：确保装饰器返回包装后的函数，其实就是一个闭包函数。</li>
<li>内层<code>return result</code>：确保原函数的返回值不被丢弃</li>
</ol>
<h3 id="装饰器应用场景"><a href="#装饰器应用场景" class="headerlink" title="装饰器应用场景"></a>装饰器应用场景</h3><p>1.日志记录：在大型项目中，使用装饰器可以轻松地为多个函数添加日志功能，而无需在每个函数中重复编写日志代码。</p>
<p>2.性能分析：通过装饰器可以方便地测量函数的执行时间，帮助开发者识别性能瓶颈。</p>
<p>3.访问控制：在Web应用中，装饰器可以用于实现用户认证和授权，确保只有具有特定权限的用户才能访问某些功能。</p>
<p>4.缓存机制：对于计算密集型函数，使用缓存装饰器可以显著提高程序的执行效率，避免重复计算。</p>
<p>5.输入验证：在数据处理应用中，装饰器可以用于检查函数输入的有效性，提高代码的健壮性。</p>
<h3 id="装饰器函数示例"><a href="#装饰器函数示例" class="headerlink" title="装饰器函数示例"></a>装饰器函数示例</h3><h4 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># logging.getLogger().setLevel(logging.INFO)</span></span><br><span class="line">        logging.info(<span class="string">f&quot;调用函数: <span class="subst">&#123;func.__name__&#125;</span>, 参数: <span class="subst">&#123;args&#125;</span>, <span class="subst">&#123;kwargs&#125;</span>&quot;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        logging.info(<span class="string">f&quot;函数返回: <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@log_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;两数相加&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">add(<span class="number">3</span>, <span class="number">5</span>)  <span class="comment"># 自动记录日志</span></span><br></pre></td></tr></table></figure>

<p><strong>代码解析</strong></p>
<ol>
<li><code>@log_decorator</code>是装饰器的应用方式，相当于：<code>add = log_decorator(add)</code></li>
<li>装饰器返回的<code>wrapper</code>函数能够访问外部函数<code>log_decorator</code>的作用域，因此可以在原函数执行前后插入自己的逻辑。</li>
</ol>
<h4 id="函数计时"><a href="#函数计时" class="headerlink" title="函数计时"></a>函数计时</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">        t1=time.time()</span><br><span class="line">        <span class="comment"># 这是函数真正执行的地方</span></span><br><span class="line">        func(*args, **kw)</span><br><span class="line">        t2=time.time()</span><br><span class="line">        <span class="comment"># 计算下时长</span></span><br><span class="line">        cost_time = t2-t1 </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;花费时间：&#123;&#125;秒&quot;</span>.<span class="built_in">format</span>(cost_time))</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">want_sleep</span>(<span class="params">sleep_time</span>):</span><br><span class="line">    time.sleep(sleep_time)</span><br><span class="line"></span><br><span class="line">want_sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<h4 id="函数重试"><a href="#函数重试" class="headerlink" title="函数重试"></a>函数重试</h4><p>若需要为装饰器传递参数（如重试次数），需定义一个<strong>装饰器工厂函数</strong>，它可以根据参数“生产”出不同的装饰器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repeat</span>(<span class="params">num_times</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_times):</span><br><span class="line">                result = func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@repeat(<span class="params">num_times=<span class="number">3</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&quot;Alice&quot;</span>)  <span class="comment"># 输出3次&quot;Hello Alice!&quot;</span></span><br></pre></td></tr></table></figure>

<p>从以上例子中可以看到，在带参数的装饰器函数中一共有三层函数嵌套，其实剥离出最外面的一层，我们可以发现和简单（不带参数）的装饰器是一样的。</p>
<p><strong>代码解析</strong>：</p>
<ul>
<li><code>repeat</code>是一个装饰器工厂函数，负责“生产”返回一个实际的装饰器<code>decorator</code>。</li>
<li><code>@repeat(num_times=3)</code>等价于<code>greet = repeat(3)(greet)</code>。</li>
</ul>
<h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>绝大多数装饰器都是基于函数和闭包实现的，但这并非制造装饰器的唯一方式。事实上，Python 对某个对象是否能通过装饰器（<code>@decorator</code>）形式使用只有一个要求：<strong>decorator 必须是一个“可被调用（callable）的对象</strong>。</p>
<p>基于类装饰器的实现，必须实现 <code>__call__</code> 和 <code>__init__</code>两个内置函数。</p>
<h4 id="不带参数的类装饰器"><a href="#不带参数的类装饰器" class="headerlink" title="不带参数的类装饰器"></a>不带参数的类装饰器</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):	<span class="comment"># 接收被装饰函数</span></span><br><span class="line">        <span class="variable language_">self</span>.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):	<span class="comment"># 实现装饰逻辑。</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;函数 <span class="subst">&#123;self.func.__name__&#125;</span> 被调用&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line">say_hello()  <span class="comment"># 输出: 函数 say_hello 被调用 → Hello!</span></span><br></pre></td></tr></table></figure>

<p>在不带参数的类装饰器中，等价于 <code>func = class(func)</code>，此时函数作为了类的实例参数。</p>
<h4 id="带参数的类装饰器"><a href="#带参数的类装饰器" class="headerlink" title="带参数的类装饰器"></a>带参数的类装饰器</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">logger</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, level=<span class="string">&#x27;INFO&#x27;</span></span>):	<span class="comment"># 接受装饰器参数</span></span><br><span class="line">        <span class="variable language_">self</span>.level = level</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, func</span>): <span class="comment"># 接受被装饰函数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[&#123;level&#125;]: the function &#123;func&#125;() is running...&quot;</span>\</span><br><span class="line">                .<span class="built_in">format</span>(level=<span class="variable language_">self</span>.level, func=func.__name__))</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper  <span class="comment">#返回函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logger(<span class="params">level=<span class="string">&#x27;WARNING&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">something</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;say &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something))</span><br><span class="line"></span><br><span class="line">say(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在带参数的类装饰器中，等价于<code>func = class(para)(func)</code>。也就是说，此时函数并不是实例化参数，而变成了callable 的参数，这也就是为什么需要在__call__() 中传入func。</p>
<h3 id="内置装饰器"><a href="#内置装饰器" class="headerlink" title="内置装饰器"></a>内置装饰器</h3><p>Python还提供了一些常用的内置装饰器。例如：</p>
<ul>
<li><code>@property</code>：用于将一个方法转换为属性。广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查。</li>
<li><code>@staticmethod</code> 和 <code>@classmethod</code>：用于定义静态方法和类方法。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>装饰器是闭包的一种应用，闭包为装饰器提供了“记住外部函数参数（如被装饰函数 <code>func</code>）”的能力。</li>
<li>一切 callable 的对象都可以被用来实现装饰器，比如函数、类。</li>
<li>装饰器会改变原函数的原始签名，需要使用 <code>functools.wraps</code></li>
<li>在内层函数修改外层函数的变量时，需要使用 <code>nonlocal</code> 关键字。</li>
<li>“装饰器”并没有提供某种无法替代的功能，等同于<code>func = decorator(func)</code>。它只是一颗“语法糖”而已，就像乐高积木，可以自由组合各种功能模块，在某些特定场景里可以使代码更简洁易维护。</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
